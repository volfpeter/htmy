{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Source code: https://github.com/volfpeter/htmy</p> <p>Documentation and examples: https://volfpeter.github.io/htmy</p>"},{"location":"#htmy","title":"<code>htmy</code>","text":"<p>Async, pure-Python server-side rendering engine.</p> <p>Unleash your creativity with the full power and Python, without the hassle of learning a new templating language or dealing with its limitations!</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Async-first, to let you make the best use of modern async tools.</li> <li>Powerful, React-like context support, so you can avoid prop-drilling.</li> <li>Sync and async function components with decorator syntax.</li> <li>All baseline HTML tags built-in.</li> <li>Support for native HTML/XML documents with dynamic formatting and slot rendering, without custom syntax.</li> <li>Markdown support with tools for customization.</li> <li>Async, JSON based internationalization.</li> <li>Built-in, easy to use <code>ErrorBoundary</code> component for graceful error handling.</li> <li>Unopinionated: use the backend, CSS, and JS frameworks of your choice, the way you want to use them.</li> <li>Everything is easily customizable, from the rendering engine to components, formatting and context management.</li> <li>Automatic and customizable property-name conversion from snake case to kebab case.</li> <li>Compatible with any other templating library through wrappers.</li> <li>Fully-typed.</li> </ul>"},{"location":"#testimonials","title":"Testimonials","text":"<p>\"Thank you for your work on <code>fasthx</code>, as well as <code>htmy</code>! I've never had an easier time developing with another stack.\" (ref)</p> <p>\"One of the main parts of the <code>FastAPI</code> -&gt; <code>fasthx</code> -&gt; <code>htmy</code> integration I'm falling in love with is its explicitness, and not too much magic happening.\" (ref)</p> <p>\"Thank you for your work on <code>htmy</code> and <code>fasthx</code>, both have been very pleasant to use, and the APIs are both intuitive and simple. Great work.\" (ref)</p> <p>\"I love that the language-embedded HTML generation library approach is becoming more popular.\" (ref)</p> <p>\"Neat approach and it naturally solves the partial templates problem \ud83d\udc4d\" (ref)</p> <p>\"Great API design!\" (ref)</p>"},{"location":"#support","title":"Support","text":"<p>Consider supporting the development and maintenance of the project through sponsoring, or reach out for consulting so you can get the most out of the library.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed with:</p> <pre><code>$ pip install htmy\n</code></pre> <p>The package has the following optional dependencies:</p> <ul> <li><code>lxml</code> (recommended): When installed, it is prioritized over <code>xml.etree.ElementTree</code> and provides more secure, faster, and more flexible HTML and XML processing. It is used, for example, for Markdown processing. Install with: <code>pip install \"htmy[lxml]\"</code>.</li> </ul>"},{"location":"#concepts","title":"Concepts","text":"<p>The entire library -- from the rendering engine itself to the built-in components -- is built around a few simple protocols and a handful of simple utility classes. This means that you can easily customize, extend, or replace basically everything in the library. Yes, even the rendering engine. The remaining parts will keep working as expected.</p> <p>Also, the library doesn't rely on advanced Python features such as metaclasses or descriptors. There are also no complex base classes and the like. Even a junior engineer could understand, develop, and debug an application that's built with <code>htmy</code>.</p>"},{"location":"#components","title":"Components","text":"<p>Every object with a sync or async <code>htmy(context: Context) -&gt; Component</code> method is an <code>htmy</code> component (technically an <code>HTMYComponentType</code>). Strings are also components, as well as lists or tuples of <code>HTMYComponentType</code> or string objects. In many cases though, you don't even need to create components, simple functions that return components will be sufficient -- you can find out more about this in the Components guide of the documentation.</p> <p>Using the <code>htmy()</code> method name enables the conversion of any of your pre-existing business objects (from <code>TypedDicts</code>s or <code>pydantic</code> models to ORM classes) into components without the fear of name collision or compatibility issues with other tools.</p> <p>Async support makes it possible to load data or execute async business logic right in your components. This can reduce the amount of boilerplate you need to write in some cases, and also gives you the freedom to split the rendering and non-rendering logic in any way you see fit.</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\nfrom htmy import Component, Context, html\n\n@dataclass(frozen=True, kw_only=True, slots=True)\nclass User:\n    username: str\n    name: str\n    email: str\n\n    async def is_admin(self) -&gt; bool:\n        return False\n\nclass UserRow(User):\n    async def htmy(self, context: Context) -&gt; Component:\n        role = \"admin\" if await self.is_admin() else \"restricted\"\n        return html.tr(\n            html.td(self.username),\n            html.td(self.name),\n            html.td(html.a(self.email, href=f\"mailto:{self.email}\")),\n            html.td(role)\n        )\n\n@dataclass(frozen=True, kw_only=True, slots=True)\nclass UserRows:\n    users: list[User]\n    def htmy(self, context: Context) -&gt; Component:\n        # Note that a list is returned here. A list or tuple of `HTMYComponentType | str` objects is also a component.\n        return [UserRow(username=u.username, name=u.name, email=u.email) for u in self.users]\n\nuser_table = html.table(\n    UserRows(\n        users=[\n            User(username=\"Foo\", name=\"Foo\", email=\"foo@example.com\"),\n            User(username=\"Bar\", name=\"Bar\", email=\"bar@example.com\"),\n        ]\n    )\n)\n</code></pre> <p><code>htmy</code> also provides a powerful <code>@component</code> decorator that can be used on sync or async <code>my_component(props: MyProps, context: Context) -&gt; Component</code> functions and methods to convert them into components (preserving the <code>props</code> typing). You can find out more about this feature in the Function components guide.</p> <p>Here is the same example as above, but with function components:</p> <pre><code>from dataclasses import dataclass\n\nfrom htmy import Component, Context, component, html\n\n@dataclass(frozen=True, kw_only=True, slots=True)\nclass User:\n    username: str\n    name: str\n    email: str\n\n    async def is_admin(self) -&gt; bool:\n        return False\n\n@component\nasync def user_row(user: User, context: Context) -&gt; Component:\n    # The first argument of function components is their \"props\", the data they need.\n    # The second argument is the rendering context.\n    role = \"admin\" if await user.is_admin() else \"restricted\"\n    return html.tr(\n        html.td(user.username),\n        html.td(user.name),\n        html.td(html.a(user.email, href=f\"mailto:{user.email}\")),\n        html.td(role)\n    )\n\n@component\ndef user_rows(users: list[User], context: Context) -&gt; Component:\n    # Nothing to await in this component, so it's sync.\n    # Note that we only pass the \"props\" to the user_row() component (well, function component wrapper).\n    # The context will be passed to the wrapper during rendering.\n    return [user_row(user) for user in users]\n\nuser_table = html.table(\n    user_rows(\n        [\n            User(username=\"Foo\", name=\"Foo\", email=\"foo@example.com\"),\n            User(username=\"Bar\", name=\"Bar\", email=\"bar@example.com\"),\n        ]\n    )\n)\n</code></pre>"},{"location":"#built-in-components","title":"Built-in components","text":"<p><code>htmy</code> has a rich set of built-in utilities and components for both HTML and other use-cases:</p> <ul> <li><code>html</code> module: a complete set of baseline HTML tags.</li> <li><code>Snippet</code> and <code>Slots</code>: utilities for creating dynamic, customizable document snippets in their native file format (HTML, XML, Markdown, etc.), with slot rendering support.</li> <li><code>md</code>: <code>MarkdownParser</code> utility and <code>MD</code> component for loading, parsing, converting, and rendering markdown content.</li> <li><code>i18n</code>: utilities for async, JSON based internationalization.</li> <li><code>BaseTag</code>, <code>TagWithProps</code>, <code>Tag</code>, <code>WildcardTag</code>: base classes for custom XML tags.</li> <li><code>ErrorBoundary</code>, <code>Fragment</code>, <code>SafeStr</code>, <code>WithContext</code>: utilities for error handling, component wrappers, context providers, and formatting.</li> <li><code>etree.ETreeConverter</code>: utility that converts XML to a component tree with support for custom HTMY components.</li> </ul>"},{"location":"#rendering","title":"Rendering","text":"<p><code>htmy.Renderer</code> is the built-in, default renderer of the library.</p> <p>If you're using the library in an async web framework like FastAPI, then you're already in an async environment, so you can render components as simply as this: <code>await Renderer().render(my_root_component)</code>.</p> <p>If you're trying to run the renderer in a sync environment, like a local script or CLI, then you first need to wrap the renderer in an async task and execute that task with <code>asyncio.run()</code>:</p> <pre><code>import asyncio\n\nfrom htmy import Renderer, html\n\nasync def render_page() -&gt; None:\n    page = (\n        html.DOCTYPE.html,\n        html.html(\n            html.body(\n                html.h1(\"Hello World!\"),\n                html.p(\"This page was rendered by \", html.code(\"htmy\")),\n            ),\n        )\n    )\n\n    result = await Renderer().render(page)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(render_page())\n</code></pre>"},{"location":"#context","title":"Context","text":"<p>As you could see from the code examples above, every component has a <code>context: Context</code> argument, which we haven't used so far. Context is a way to share data with the entire subtree of a component without \"prop drilling\".</p> <p>The context (technically a <code>Mapping</code>) is entirely managed by the renderer. Context provider components (any class with a sync or async <code>htmy_context() -&gt; Context</code> method) add new data to the context to make it available to components in their subtree (including themselves), and components can simply take what they need from the context.</p> <p>There is no restriction on what can be in the context, it can be used for anything the application needs, for example making the current user, UI preferences, themes, or formatters available to components. In fact, built-in components get their <code>Formatter</code> from the context if it contains one, to make it possible to customize tag property name and value formatting.</p> <p>Here's an example context provider and consumer implementation:</p> <pre><code>import asyncio\n\nfrom htmy import Component, ComponentType, Context, Renderer, component, html\n\nclass UserContext:\n    def __init__(self, *children: ComponentType, username: str, theme: str) -&gt; None:\n        self._children = children\n        self.username = username\n        self.theme = theme\n\n    def htmy_context(self) -&gt; Context:\n        # Context provider implementation.\n        return {UserContext: self}\n\n    def htmy(self, context: Context) -&gt; Component:\n        # Context providers must also be components, as they just\n        # wrap some children components in their context.\n        return self._children\n\n    @classmethod\n    def from_context(cls, context: Context) -&gt; \"UserContext\":\n        user_context = context[cls]\n        if isinstance(user_context, UserContext):\n            return user_context\n\n        raise TypeError(\"Invalid user context.\")\n\n@component\ndef welcome_page(text: str, context: Context) -&gt; Component:\n    # Get user information from the context.\n    user = UserContext.from_context(context)\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.body(\n                html.h1(text, html.strong(user.username)),\n                data_theme=user.theme,\n            ),\n        ),\n    )\n\nasync def render_welcome_page() -&gt; None:\n    page = UserContext(\n        welcome_page(\"Welcome back \"),\n        username=\"John\",\n        theme=\"dark\",\n    )\n\n    result = await Renderer().render(page)\n    print(result)\n\nif __name__ == \"__main__\":\n    asyncio.run(render_welcome_page())\n</code></pre> <p>You can of course rely on the built-in context related utilities like the <code>ContextAware</code> or <code>WithContext</code> classes for convenient and typed context use with less boilerplate code.</p>"},{"location":"#formatter","title":"Formatter","text":"<p>As mentioned before, the built-in <code>Formatter</code> class is responsible for tag attribute name and value formatting. You can completely override or extend the built-in formatting behavior simply by extending this class or adding new rules to an instance of it, and then adding the custom instance to the context, either directly in <code>Renderer</code> or <code>Renderer.render()</code>, or in a context provider component.</p> <p>These are default tag attribute formatting rules:</p> <ul> <li>Underscores are converted to dashes in attribute names (<code>_</code> -&gt; <code>-</code>) unless the attribute name starts or ends with an underscore, in which case leading and trailing underscores are removed and the rest of attribute name is preserved. For example <code>data_theme=\"dark\"</code> is converted to <code>data-theme=\"dark\"</code>, but <code>_data_theme=\"dark\"</code> will end up as <code>data_theme=\"dark\"</code> in the rendered text. More importantly <code>class_=\"text-danger\"</code>, <code>_class=\"text-danger\"</code>, <code>_class__=\"text-danger\"</code> are all converted to <code>class=\"text-danger\"</code>, and <code>_for=\"my-input\"</code> or <code>for_=\"my_input\"</code> will become <code>for=\"my-input\"</code>.</li> <li><code>bool</code> attribute values are converted to strings (<code>\"true\"</code> and <code>\"false\"</code>).</li> <li><code>XBool.true</code> attributes values are converted to an empty string, and <code>XBool.false</code> values are skipped (only the attribute name is rendered).</li> <li><code>date</code> and <code>datetime</code> attribute values are converted to ISO strings.</li> <li>Complex values such as lists, dictionaries, tuples, and sets are JSON serialized.</li> </ul>"},{"location":"#error-boundary","title":"Error boundary","text":"<p>The <code>ErrorBoundary</code> component is useful if you want your application to fail gracefully (e.g. display an error message) instead of raising an HTTP error.</p> <p>The error boundary wraps a component component subtree. When the renderer encounters an <code>ErrorBoundary</code> component, it will try to render its wrapped content. If rendering fails with an exception at any point in the <code>ErrorBoundary</code>'s subtree, the renderer will automatically fall back to the component you assigned to the <code>ErrorBoundary</code>'s <code>fallback</code> property.</p> <p>Optionally, you can define which errors an error boundary can handle, giving you fine control over error handling.</p>"},{"location":"#sync-or-async","title":"Sync or async?","text":"<p>In general, a component should be async if it must await some async call inside.</p> <p>If a component executes a potentially \"long-running\" synchronous call, it is strongly recommended to delegate that call to a worker thread an await it (thus making the component async). This can be done for example with <code>anyio</code>'s <code>to_thread</code> utility, <code>starlette</code>'s (or <code>fastapi</code>'s) <code>run_in_threadpool()</code>, and so on. The goal here is to avoid blocking the asyncio event loop, as that can lead to performance issues.</p> <p>In all other cases, it's best to use sync components.</p>"},{"location":"#xss-prevention","title":"XSS prevention","text":"<p><code>htmy</code> does XML/HTML escaping by default. This means user input is normally sanitized and rendered safely.</p> <p>There are a couple of notable exceptions to this, where components by design allow XML/HTML inputs and assume they are safe:</p> <ul> <li><code>Snippet</code>: The primary use-case is to efficiently render XML/HTML templates, filling in placeholders with dynamic content. In this case you must ensure that the input template itself is safe!</li> <li><code>MD</code>: This component builds on <code>Snippet</code> to support markdown inputs and performs automatic markdown to HTML conversion. You must ensure the input text is safe!</li> </ul>"},{"location":"#ai-assistance","title":"AI assistance","text":"<p>The library is registered at Context7.</p> <p>To get good AI assistance, all you need to do is register the Context7 MCP server in your coding tool and tell the agent to use it.</p> <p>Because of the similarity with native HTML, JSX, and React, you can expect good results, both for vibe coding or inline completion.</p>"},{"location":"#compatibility-and-performance","title":"Compatibility and performance","text":"<p>By design, <code>htmy</code> is compatible with any other Python templating library, for example Jinja, through wrappers. A wrapper is simply a custom <code>htmy</code> component that internally offloads rendering to another templating framework. This makes it possible to easily combine <code>htmy</code> with other libraries, to gradually adopt it, and even to enjoy the benefits of multiple frameworks.</p> <p>Performance strongly depends on how you use <code>htmy</code>. The <code>Snippet</code> component for example makes it possible to reach almost Python string formatting performance, while rendering large, deep component trees is noticeably slower than Jinja for example. Wrapping another templating library for certain use-cases, or pre-rendering components and later using <code>Snippet</code> to fill in the dynamic content can be beneficial for performance.</p>"},{"location":"#framework-integrations","title":"Framework integrations","text":"<p>FastAPI:</p> <ul> <li>holm: Web development framework that brings the Next.js developer experience to Python, built on FastAPI, htmy, and FastHX.</li> <li>FastHX: Declarative server-side rendering utility for FastAPI with built-in HTMX support.</li> </ul>"},{"location":"#why","title":"Why","text":"<p>At one end of the spectrum, there are the complete application frameworks that combine the server (Python) and client (JavaScript) applications with the entire state management and synchronization into a single Python (an in some cases an additional JavaScript) package. Some of the most popular examples are: Reflex, NiceGUI, ReactPy, and FastUI.</p> <p>The main benefit of these frameworks is rapid application prototyping and a very convenient developer experience, at least as long as you stay within the built-in feature set of the framework. In exchange for that, they are very opinionated (from components to frontend tooling and state management), the underlying engineering is very complex, deployment and scaling can be hard or costly, and they can be hard to migrate away from. Even with these caveats, they can be a very good choice for internal tools and application prototyping.</p> <p>The other end of spectrum -- plain rendering engines -- is dominated by the Jinja templating engine, which is a safe choice as it has been and will be around for a long time. The main drawbacks with Jinja are the lack of good IDE support, the complete lack of static code analysis support, and the (subjectively) ugly custom template syntax.</p> <p>Then there are tools that aim for the middleground, usually by providing most of the benefits and drawbacks of complete application frameworks while leaving state management, client-server communication, and dynamic UI updates for the user to solve, often with some level of HTMX support. This group includes libraries like FastHTML and Ludic.</p> <p>The primary aim of <code>htmy</code> is to be a <code>Jinja</code> alternative that is similarly powerful and flexible, while also providing the benefits of full IDE support, static code analysis, and native Python (and HTML, XML, markdown) syntax. Additionally, <code>htmy</code> is async-first, so it works great with modern async Python frameworks such as FastAPI. The library was designed to be as simple, maintainable, and customizable as possible, while still providing all the building blocks for creating complex web applications.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The library aims to minimze its dependencies. Currently the following dependencies are required:</p> <ul> <li><code>anyio</code>: for async file operations and networking.</li> <li><code>async-lru</code>: for async caching.</li> <li><code>markdown</code>: for markdown parsing.</li> </ul>"},{"location":"#development","title":"Development","text":"<p>Use <code>ruff</code> for linting and formatting, <code>mypy</code> for static code analysis, and <code>pytest</code> for testing.</p> <p>The documentation is built with <code>mkdocs-material</code> and <code>mkdocstrings</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community to help improve the project! Whether you're an experienced developer or just starting out, there are many ways you can contribute:</p> <ul> <li>Discuss: Join our Discussion Board to ask questions, share ideas, provide feedback, and engage with the community.</li> <li>Document: Help improve the documentation by fixing typos, adding examples, and updating guides to make it easier for others to use the project.</li> <li>Develop: Prototype requested features or pick up issues from the issue tracker.</li> <li>Share: Share your own project by adding a link to it in the documentation, helping others discover and benefit from your work.</li> <li>Test: Write tests to improve coverage and enhance reliability.</li> </ul>"},{"location":"#license-mit","title":"License - MIT","text":"<p>The package is open-sourced under the conditions of the MIT license.</p>"},{"location":"components-guide/","title":"Components guide","text":""},{"location":"components-guide/#what-is-a-component","title":"What is a component?","text":"<p>Every object with a sync or async <code>htmy(context: Context) -&gt; Component</code> method is an <code>htmy</code> component (technically an <code>HTMYComponentType</code>). Strings are also components, as well as lists or tuples of <code>HTMYComponentType</code> or string objects.</p> <p>Using the <code>htmy()</code> method name enables the conversion of any of your pre-existing business objects and Python utilities -- from <code>TypedDicts</code>s or <code>pydantic</code> models to ORM classes, and even advanced constructs like descriptors -- into components without the fear of name collision or compatibility issues with other tools.</p> <p>(Note: while many code examples in the documentation use <code>dataclasses</code> to create components, the only reason for this is that <code>dataclasses</code> save a lot of boilerplate code and make the examples more readable.)</p> <p>With the technical details out of the way, let's see some examples with built-in Python types:</p> <pre><code>import asyncio\nfrom datetime import datetime\n\nfrom htmy import Component, ComponentType, Context, Renderer, html, join_components\n\n\nclass HTMYDatetime(datetime):\n    \"\"\"\n    Datetime subclass that's also a component thanks to its `htmy()` classmethod.\n\n    The class itself is the component. Rendering either the class or an instance\n    of it creates a `&lt;p&gt;` tag with the *current* date and time information in it.\n    \"\"\"\n\n    @classmethod\n    def htmy(cls, _: Context) -&gt; Component:\n        return html.p(\"The current date and time is: \", cls.now().isoformat())\n\n\nclass ULDict(dict[str, ComponentType]):\n    \"\"\"\n    Dictionary that maps string keys to `htmy` components.\n\n    Instances of this dictionary are `htmy` components, that render the items in\n    the dictionary as `&lt;li&gt;` tags inside a `&lt;ul&gt;` tag.\n    \"\"\"\n\n    def htmy(self, _: Context) -&gt; Component:\n        return html.ul(*(html.li(k, \": \", v) for k, v in self.items()))\n\n\nclass Coordinate(tuple[float, float, float]):\n    \"\"\"\n    Tuple that represents a 3D coordinate.\n\n    During rendering, an origin coordinate is loaded from the rendering context,\n    and the calculated absolute coordinate will be rendered as a `&lt;p&gt;` tag.\n    \"\"\"\n\n    def htmy(self, context: Context) -&gt; Component:\n        origin: tuple[float, float, float] = context[\"origin\"]\n        return html.p(f\"Coordinates: ({self[0] + origin[0]}, {self[1] + origin[1]}, {self[2] + origin[2]})\")\n\n\nclass OrderedList(list[ComponentType]):\n    \"\"\"\n    List of `htmy` components.\n\n    Instances are rendered as an `&lt;ol&gt;` tag with the list items inside, wrapped by `&lt;li&gt;` tags.\n    \"\"\"\n\n    def htmy(self, _: Context) -&gt; Component:\n        return html.ol(*(html.li(item) for item in self))\n\n\nclass HexBytes(bytes):\n    \"\"\"\n    `bytes` object that renders its individual bytes as hexadecimal strings,\n    separated by spaces, in a `&lt;p&gt;` tag.\n    \"\"\"\n\n    def htmy(self, _: Context) -&gt; Component:\n        return html.p(*join_components(tuple(f\"0x{b:X}\" for b in self), \" \"))\n</code></pre> <p>Now, let's render these components to see how they can be used:</p> <pre><code>async def render() -&gt; None:\n    renderer = Renderer()\n    result = await renderer.render(\n        html.div(\n            HTMYDatetime,\n            HTMYDatetime(2025, 2, 25),\n            ULDict(one=\"First\", two=\"Second\", three=\"Third\"),\n            Coordinate((1, 6, 1)),\n            OrderedList([Coordinate((1, 2, 3)), Coordinate((4, 5, 6))]),\n            HexBytes(b\"Hello!\"),\n        ),\n        # Add an origin coordinate to the context for Coordinate to use.\n        {\"origin\": (3, 1, 4)},\n    )\n    print(f\"Result:\\n{result}\")\n\n\nasyncio.run(render())\n</code></pre> <p>You can use these patterns to enhance your existing business objects with rendering capabilities, without affecting their original functionality in any way.</p> <p>The use of context -- and async support if you're using async tools like FastAPI -- makes these patterns even more powerful. Imagine, that you have a web application in which the client submits an <code>X-Variant</code> request header to tell the server how to render the response (typical scenario with HTMX), for example as a list item or a table row. If you add this information to the rendering context, your enhanced business objects can use this information to conditionally fetch more data and render themselves the way the client requested. (This is facilitated out of the box by FastHX for example.)</p> <p>Here is the pseudo-code for the above scenario:</p> <pre><code>@dataclass\nclass User:\n    name: str\n    email: str\n    permissions: list[str] | None = None\n\n    async def htmy(self, context: Context) -&gt; Component:\n        request_headers = context[\"request_headers\"]\n        variant = request_headers.get(\"X-Variant\", \"list-item\")\n        if variant == \"list-item\":\n            return await self._htmy_li(context)\n        elif variant == \"table-row\":\n            return await self._htmy_tr(context)\n        else:\n            raise ValueError(\"Unknown variant\")\n\n    async def _htmy_li(self, context: Context) -&gt; Component:\n        return html.li(...)\n\n    async def _htmy_tr(self, context: Context) -&gt; Component:\n        # Make sure permissions are loaded, the table row representation needs them.\n        await self._load_permissions()\n        return html.tr(...)\n\n    async def _load_permissions(self) -&gt; None:\n        # Load user permissions and store them in self.permissions.\n        ...\n</code></pre> <p>Hopefully these examples give you some ideas on how you can efficiently integrate <code>htmy</code> into your application and business logic.</p> <p>Unleash your creativity, and have fun building your next web application! And of course join our Discussion Board to share your cool patterns and use-cases with the community.</p>"},{"location":"components-guide/#what-is-a-component-factory","title":"What is a component factory?","text":"<p>So far we only talked about components, but often you do not need to create full-fledged <code>htmy</code> components, all you need is a function that accepts some arguments and returns a component. Such functions are called component factories.</p> <pre><code>def heading(text: str) -&gt; html.h1:\n    \"\"\"Heading component factory.\"\"\"\n    return html.h1(text)\n\ndef paragraph(text: str) -&gt; html.p:\n    \"\"\"Paragraph component factory.\"\"\"\n    return html.p(text)\n\ndef section(title: str, text: str) -&gt; html.div:\n    \"\"\"\n    This is not a component, just a factory that is evaluated to a component\n    immediately when called. The renderer will only need to resolve the inner\n    `div` and its children.\n    \"\"\"\n    return html.div(\n        heading(title),  # Calling a component factory here.\n        paragraph(text), # Calling a component factory here as well.\n    )\n</code></pre> <p>Of course, instance, class, and static methods, even properties or more advanced Python constructs like descriptors can also act as component factories, giving you a lot of flexibility in how you add <code>htmy</code> rendering support to your codebase.</p> <p>Component factories come with some advantages, mainly simplicity and somewhat better performance. The performance benefit comes from the fact these functions are executed instantly, and the <code>htmy</code> renderer only needs to resolve the resulting component tree, which will be smaller than the one that uses components for everything.</p> <p>Component factories come with some limitations and downsides though:</p> <ul> <li>Often they can not be async, because they are called from sync code.</li> <li>They have no access to the rendering context.</li> <li>They can not act as context providers.</li> <li>They are immediately evaluated, which can be undesirable if they create a large component tree.</li> </ul> <p>Note that when you create the component tree you want to render, you (almost) always \"call\" something with some arguments: either a component factory or an actual component class, the latter of which is just the instantiation of the component class (potentially an enhanced business object).</p> <p>There is one important detail you must pay attention to: if a component factory returns a component sequence, then it's up to you make sure the returned component sequence is correctly passed to the \"parent\" component or component factory, because for example <code>list[list[ComponentType]]</code> is not a valid component sequence, only <code>list[ComponentType]</code> is. List unpacking and the built-in <code>Fragment</code> component can help you avoid potential issues.</p> <p>It may be unnecessary to say, but you don't need to bother with the above issue if you use components, they can return component sequences and the renderer will deal with them, it's a standard use-case.</p>"},{"location":"components-guide/#when-to-use-components-when-to-use-component-factories","title":"When to use components, when to use component factories?","text":"<p>There is no hard rule, but hopefully the previous sections gave you enough guidance to make an informed decision in every case. In general, if a component factory is enough, then it's often the better choice, but if you feel safer using only components, then that's just as good.</p>"},{"location":"function-components/","title":"Function components","text":"<p>The default and most flexible way to define an <code>htmy</code> component is to add a sync or async <code>htmy(self, context: Context) -&gt; Component</code> method to a class, often to enhance a pre-existing business object with <code>htmy</code> rendering capabilities.</p> <p>However, in many cases, especially when you're not enhancing an existing class, this ends up being very verbose and requires a lot of boilerplate: you need to define a class, add the necessary properties, and finally implement the <code>htmy()</code> method. This is especially impractical when the component has no properties.</p> <p>Function components address these issues by allowing you to fully skip class creation and define the component simply as a function (well, or method, as we'll see later). This removes the need for any boilerplate, while also making the code more concise and easier to read.</p>"},{"location":"function-components/#function-component-types","title":"Function component types","text":"<p>Fundamentally, there are two kinds of function components, both of which may of course be sync or async.</p> <p>The \"classic\" function component expects a properties and a context argument, and returns a <code>Component</code>: <code>def fc(props: Props, context: Context) -&gt; Component</code>. This kind of function component is useful when the component requires properties and also uses the rendering context, for example to get access to the request object, the translation function, a style provider, etc..</p> <p>Often, components don't need properties, only access to the rendering context. This use-case is addressed by \"context-only\" function components, which only expect a context argument: <code>def context_only_fc(context: Context) -&gt; Component</code>.</p> <p>You may ask what if a \"component\" only needs properties, but not the context? Or if it doesn't need either? The answer is these functions are not really components, rather just \"component factories\". You can find out more about them in the Components guide.</p> <p>There is another question that naturally arises: can the instance methods of a class also be function components? The answer is of course yes, which means that in total there are four types of function components.</p> <ul> <li>Functions with a properties and a context argument.</li> <li>Functions with only a context argument.</li> <li>Instance methods with a properties and a context argument.</li> <li>Instance methods with only a context argument.</li> </ul>"},{"location":"function-components/#creating-function-components","title":"Creating function components","text":"<p>We've discussed the four types of function components and their signatures (protocol/interface definition) in the previous section, but such functions are not automatically components, because they do not have an <code>htmy()</code> method.</p> <p>To turn these functions into components, you need to decorate them with the <code>@component</code> decorator. Actually, since all four types of function components look different (remember that methods require the <code>self</code> argument as well), the <code>@component</code> decorator has one variant for each of them:</p> <ul> <li><code>@component</code> (and its <code>@component.function</code> alias) for functions with a properties and a context argument.</li> <li><code>@component.context_only</code> for functions with only a context argument.</li> <li><code>@component.method</code> for instance methods with a properties and a context argument.</li> <li><code>@component.context_only_method</code> for instance methods with only a context argument.</li> </ul> <p>Technical note: the <code>@component</code> decorators change the decorated function's signature. After the decorator is applied, the resulting component will be callable with only the function component's properties (if any), and the returned object will have the <code>htmy(context: Context) -&gt; Component</code> method that the renderer will call with the context during rendering. As a result, the decorated function will only be executed when the component is rendered.</p> <p>If it sounded complicated and overly technical, don't worry, function components will feel trivial once you see them in action.</p>"},{"location":"function-components/#examples","title":"Examples","text":"<p>Before we dive into the actual components, let's import what we need and create a few utilities, just to have some data to work with. The examples assume that <code>htmy</code> is installed.</p> <pre><code>import asyncio\nfrom dataclasses import dataclass\nfrom typing import Callable\n\nfrom htmy import Context, Renderer, component, html\n\n@dataclass\nclass User:\n    \"\"\"User model.\"\"\"\n\n    username: str\n    email: str\n    status: str\n\nusers = [\n    User(\"alice\", \"alice@example.ccm\", \"active\"),\n    User(\"bob\", \"bob@example.ccm\", \"pending\"),\n    User(\"charlie\", \"charlie@example.ccm\", \"archived\"),\n    User(\"dave\", \"dave@example.ccm\", \"active\"),\n]\n\ndef css_provider(key: str) -&gt; str:\n    \"\"\"A dummy style provider function.\"\"\"\n    return key\n\nrenderer = Renderer(\n    {\n        # Add the style provider function to the default rendering context\n        # so we can always use it in our components.\n        \"css\": css_provider\n    }\n)\n</code></pre>"},{"location":"function-components/#functions","title":"Functions","text":"<p>First let's create a component that renders a user as a styled list item. The \"properties\" of this component is the user we want to render, and the context is used to get access to the style provider for styling.</p> <pre><code>@component\ndef user_list_item(user: User, context: Context) -&gt; html.li:\n    \"\"\"\n    Function component that renders a user as a list item.\n    \"\"\"\n    css: Callable[[str], str] = context[\"css\"]\n    return html.li(\n        html.label(user.username),\n        class_=css(user.status),\n    )\n</code></pre> <p>Next we create a component renders a list of users. This component is implemented similarly to the list item component, except here we use the <code>@component.function</code> decorator (which is just an alias for <code>@component</code>), and the decorated function is async, just to showcase that it also works.</p> <pre><code>@component.function  # @component.function is just an alias for @component\nasync def user_list(users: list[User], context: Context) -&gt; html.ul:\n    \"\"\"\n    Function component that renders the given list of users.\n    \"\"\"\n    css: Callable[[str], str] = context[\"css\"]\n    return html.ul(\n        *(\n            # Render each user using the user_list_item component.\n            # Notice that we call the component with only its properties object (the user).\n            user_list_item(user)\n            for user in users\n        ),\n        class_=css(\"unordered-list\"),\n    )\n</code></pre> <p>Finally, let's also create a context-only component. This will show a styled page with a heading and the list of users. The pattern is the same as before, but in this case the <code>@component.context_only</code> decorator is used and the function only accepts a context argument (no properties).</p> <pre><code>@component.context_only\ndef users_page(context: Context) -&gt; html.div:\n    \"\"\"\n    Context-only function component that renders the users page.\n    \"\"\"\n    css: Callable[[str], str] = context[\"css\"]\n    return html.div(\n        html.h1(\"Users:\", class_=css(\"heading\")),\n        # Render users using the user_list component.\n        # Notice that we call the component with only its properties (the list of users).\n        user_list(users),\n        class_=css(\"page-layout\"),\n    )\n</code></pre> <p>With all the components ready, we can now render the <code>users_page</code> component and have a look at the result:</p> <pre><code>rendered = asyncio.run(\n    renderer.render(\n        # Notice that we call the users_page component with no arguments,\n        # since this component has no properties.\n        users_page()\n    )\n)\nprint(rendered)\n</code></pre> <p>It wasn't complicated, was it?</p>"},{"location":"function-components/#methods","title":"Methods","text":"<p>Having seen how to create and use function components, you probably have a very good idea of how method components work. The only difference is that we use method decorators and that we decorate instance methods.</p> <p>To reuse some code, we are going to subclass our existing <code>User</code> class and add a <code>profile_page()</code> and a context-only <code>table_row()</code> method component to the subclass. Normally, these methods would be in the <code>User</code> class, but using a subclass better suits this guide.</p> <p>It's important to know that method components can be added even to classes that are themselves components (meaning they have an <code>htmy()</code> method). The example below demonstrates this as well.</p> <pre><code>class EnhancedUser(User):\n    \"\"\"\n    `User` subclass with some method components for user rendering.\n    \"\"\"\n\n    @component.method\n    def profile_page(self, navbar: html.nav, context: Context) -&gt; html.div:\n        \"\"\"\n        Method component that renders the user's profile page.\n        \"\"\"\n        css: Callable[[str], str] = context[\"css\"]\n        return html.div(\n            navbar,\n            html.div(\n                html.p(\"Username:\"),\n                html.p(self.username),\n                html.p(\"Email:\"),\n                html.p(self.email),\n                html.p(\"Status:\"),\n                html.p(self.status),\n                class_=css(\"profile-card\"),\n            ),\n            class_=css(\"page-with-navbar\"),\n        )\n\n    @component.context_only_method\n    def table_row(self, context: Context) -&gt; html.tr:\n        \"\"\"\n        Context-only method component that renders the user as a table row.\n        \"\"\"\n        css: Callable[[str], str] = context[\"css\"]\n        return html.tr(\n            html.td(self.username, class_=css(\"primary\")),\n            html.td(self.email),\n            html.td(self.status),\n        )\n\n    def htmy(self, context: Context) -&gt; html.li:\n        \"\"\"\n        Renders the user as a styled list item.\n        \"\"\"\n        css: Callable[[str], str] = context[\"css\"]\n        return html.li(\n            html.label(self.username),\n            class_=css(self.status),\n        )\n</code></pre> <p>As you can see, method components work the same way as function componnts, except the decorated methods have the usual <code>self</code> argument, and <code>@component.method</code> and <code>@component.context_only_method</code> decorators are used instead of <code>@component</code> (<code>@component.function</code>) and <code>@component.context_only</code>.</p> <p>All that's left to do now is to create an instance of our new, <code>EnhancedUser</code> class, render its method components and the instance itself and see the result of our work.</p> <pre><code>emily = EnhancedUser(username=\"emily\", email=\"emily@example.ccm\", status=\"active\")\n\nrendered = asyncio.run(\n    renderer.render(\n        html.div(\n            # We call the user.profile_page component only with its properties.\n            emily.profile_page(html.nav(\"Navbar\")),\n            # We call the user.table_row component with no arguments, since\n            # this component has no properties.\n            emily.table_row(),\n            # EnhancedUser instances are also components, because they have an htmy() method.\n            emily,\n        )\n    )\n)\nprint(rendered)\n</code></pre> <p>That's it!</p>"},{"location":"api/core/","title":"Core","text":""},{"location":"api/core/#htmy.core","title":"<code>htmy.core</code>","text":""},{"location":"api/core/#htmy.core.BaseTag","title":"<code>BaseTag</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base tag class.</p> <p>Tags are always synchronous.</p> <p>If the content of a tag must be calculated asynchronously, then the content can be implemented as a separate async component or be resolved in an async parent component. If a property of a tag must be calculated asynchronously, then the tag can be wrapped in an async component that resolves the async content and then passes the value to the tag.</p> Source code in <code>htmy/core.py</code> <pre><code>class BaseTag(abc.ABC):\n    \"\"\"\n    Base tag class.\n\n    Tags are always synchronous.\n\n    If the content of a tag must be calculated asynchronously, then the content can be implemented\n    as a separate async component or be resolved in an async parent component. If a property of a\n    tag must be calculated asynchronously, then the tag can be wrapped in an async component that\n    resolves the async content and then passes the value to the tag.\n    \"\"\"\n\n    __slots__ = (\"_htmy_name\",)\n\n    def __init__(self) -&gt; None:\n        self._htmy_name = self._get_htmy_name()\n\n    @property\n    def htmy_name(self) -&gt; str:\n        \"\"\"The tag name.\"\"\"\n        return self._htmy_name\n\n    @abc.abstractmethod\n    def htmy(self, context: Context) -&gt; Component:\n        \"\"\"Abstract base component implementation.\"\"\"\n        ...\n\n    def _get_htmy_name(self) -&gt; str:\n        return type(self).__name__\n</code></pre>"},{"location":"api/core/#htmy.core.BaseTag.htmy_name","title":"<code>htmy_name</code>  <code>property</code>","text":"<p>The tag name.</p>"},{"location":"api/core/#htmy.core.BaseTag.htmy","title":"<code>htmy(context)</code>  <code>abstractmethod</code>","text":"<p>Abstract base component implementation.</p> Source code in <code>htmy/core.py</code> <pre><code>@abc.abstractmethod\ndef htmy(self, context: Context) -&gt; Component:\n    \"\"\"Abstract base component implementation.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#htmy.core.ContextAware","title":"<code>ContextAware</code>","text":"<p>Base class with utilities for safe context use.</p> <p>Features:</p> <ul> <li>Register subclass instance in a context.</li> <li>Load subclass instance from context.</li> <li>Wrap components within a subclass instance context.</li> </ul> <p>Subclass instance registration:</p> <p>Direct subclasses are considered the \"base context type\". Subclass instances are registered in contexts under their own type and also under their \"base context type\".</p> <p>Example:</p> <pre><code>class ContextDataDefinition(ContextAware):\n    # This is the \"base context type\", instances of this class and its subclasses\n    # will always be registered under this type.\n    ...\n\nclass ContextDataImplementation(ContextDataDefinition):\n    # Instances of this class will be registered under `ContextDataDefinition` (the\n    # \"base context type\") and also under this type.\n    ...\n\nclass SpecializedContextDataImplementation(ContextDataImplementation):\n    # Instances of this class will be registered under `ContextDataDefinition` (the\n    # \"base context type\") and also under this type, but they will not be registered\n    # under `ContextDataImplementation`, since that's not the base context type.\n    ...\n</code></pre> Source code in <code>htmy/core.py</code> <pre><code>class ContextAware:\n    \"\"\"\n    Base class with utilities for safe context use.\n\n    Features:\n\n    - Register subclass instance in a context.\n    - Load subclass instance from context.\n    - Wrap components within a subclass instance context.\n\n    Subclass instance registration:\n\n    Direct subclasses are considered the \"base context type\". Subclass instances are\n    registered in contexts under their own type and also under their \"base context type\".\n\n    Example:\n\n    ```python\n    class ContextDataDefinition(ContextAware):\n        # This is the \"base context type\", instances of this class and its subclasses\n        # will always be registered under this type.\n        ...\n\n    class ContextDataImplementation(ContextDataDefinition):\n        # Instances of this class will be registered under `ContextDataDefinition` (the\n        # \"base context type\") and also under this type.\n        ...\n\n    class SpecializedContextDataImplementation(ContextDataImplementation):\n        # Instances of this class will be registered under `ContextDataDefinition` (the\n        # \"base context type\") and also under this type, but they will not be registered\n        # under `ContextDataImplementation`, since that's not the base context type.\n        ...\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    _base_context_type: ClassVar[type[ContextAware] | None] = None\n\n    def __init_subclass__(cls) -&gt; None:\n        if cls.mro()[1] == ContextAware:\n            cls._base_context_type = cls\n\n    def in_context(self, *children: ComponentType) -&gt; WithContext:\n        \"\"\"\n        Creates a context provider component that renders the given children using this\n        instance in its context.\n        \"\"\"\n        return WithContext(*children, context=self.to_context())\n\n    def to_context(self) -&gt; Context:\n        \"\"\"\n        Creates a context with this instance in it.\n\n        See the context registration rules in the class documentation for more information.\n        \"\"\"\n        result: dict[ContextKey, ContextValue] = {type(self): self}\n        if self._base_context_type is not None:\n            result[self._base_context_type] = self\n\n        return result\n\n    @classmethod\n    def from_context(cls, context: Context, default: Self | None = None) -&gt; Self:\n        \"\"\"\n        Looks up an instance of this class from the given contexts.\n\n        Arguments:\n            context: The context the instance should be loaded from.\n            default: The default to use if no instance was found in the context.\n        \"\"\"\n        result = context[cls] if default is None else context.get(cls, default)\n        if isinstance(result, cls):\n            return result\n\n        raise TypeError(f\"Invalid context data type for {cls.__name__}.\")\n</code></pre>"},{"location":"api/core/#htmy.core.ContextAware.from_context","title":"<code>from_context(context, default=None)</code>  <code>classmethod</code>","text":"<p>Looks up an instance of this class from the given contexts.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The context the instance should be loaded from.</p> required <code>default</code> <code>Self | None</code> <p>The default to use if no instance was found in the context.</p> <code>None</code> Source code in <code>htmy/core.py</code> <pre><code>@classmethod\ndef from_context(cls, context: Context, default: Self | None = None) -&gt; Self:\n    \"\"\"\n    Looks up an instance of this class from the given contexts.\n\n    Arguments:\n        context: The context the instance should be loaded from.\n        default: The default to use if no instance was found in the context.\n    \"\"\"\n    result = context[cls] if default is None else context.get(cls, default)\n    if isinstance(result, cls):\n        return result\n\n    raise TypeError(f\"Invalid context data type for {cls.__name__}.\")\n</code></pre>"},{"location":"api/core/#htmy.core.ContextAware.in_context","title":"<code>in_context(*children)</code>","text":"<p>Creates a context provider component that renders the given children using this instance in its context.</p> Source code in <code>htmy/core.py</code> <pre><code>def in_context(self, *children: ComponentType) -&gt; WithContext:\n    \"\"\"\n    Creates a context provider component that renders the given children using this\n    instance in its context.\n    \"\"\"\n    return WithContext(*children, context=self.to_context())\n</code></pre>"},{"location":"api/core/#htmy.core.ContextAware.to_context","title":"<code>to_context()</code>","text":"<p>Creates a context with this instance in it.</p> <p>See the context registration rules in the class documentation for more information.</p> Source code in <code>htmy/core.py</code> <pre><code>def to_context(self) -&gt; Context:\n    \"\"\"\n    Creates a context with this instance in it.\n\n    See the context registration rules in the class documentation for more information.\n    \"\"\"\n    result: dict[ContextKey, ContextValue] = {type(self): self}\n    if self._base_context_type is not None:\n        result[self._base_context_type] = self\n\n    return result\n</code></pre>"},{"location":"api/core/#htmy.core.ErrorBoundary","title":"<code>ErrorBoundary</code>","text":"<p>               Bases: <code>Fragment</code></p> <p>Error boundary component for graceful error handling.</p> <p>If an error occurs during the rendering of the error boundary's subtree, the fallback component will be rendered instead.</p> Source code in <code>htmy/core.py</code> <pre><code>class ErrorBoundary(Fragment):\n    \"\"\"\n    Error boundary component for graceful error handling.\n\n    If an error occurs during the rendering of the error boundary's subtree,\n    the fallback component will be rendered instead.\n    \"\"\"\n\n    __slots__ = (\"_errors\", \"_fallback\")\n\n    def __init__(\n        self,\n        *children: ComponentType,\n        fallback: Component | None = None,\n        errors: Container[type[Exception]] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *children: The wrapped children components.\n            fallback: The fallback component to render in case an error occurs during children rendering.\n            errors: An optional set of accepted error types. Only accepted errors are swallowed and rendered\n                with the fallback. If an error is not in this set but one of its base classes is, then the\n                error will still be accepted and the fallbak rendered. By default all errors are accepted.\n        \"\"\"\n        super().__init__(*children)\n        self._errors = errors\n        self._fallback: Component = \"\" if fallback is None else fallback\n\n    def fallback_component(self, error: Exception) -&gt; ComponentType:\n        \"\"\"\n        Returns the fallback component for the given error.\n\n        Arguments:\n            error: The error that occurred during the rendering of the error boundary's subtree.\n\n        Raises:\n            Exception: The received error if it's not accepted.\n        \"\"\"\n        if not (self._errors is None or any(e in self._errors for e in type(error).mro())):\n            raise error\n\n        return as_component_type(self._fallback)\n</code></pre>"},{"location":"api/core/#htmy.core.ErrorBoundary.__init__","title":"<code>__init__(*children, fallback=None, errors=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <code>ComponentType</code> <p>The wrapped children components.</p> <code>()</code> <code>fallback</code> <code>Component | None</code> <p>The fallback component to render in case an error occurs during children rendering.</p> <code>None</code> <code>errors</code> <code>Container[type[Exception]] | None</code> <p>An optional set of accepted error types. Only accepted errors are swallowed and rendered with the fallback. If an error is not in this set but one of its base classes is, then the error will still be accepted and the fallbak rendered. By default all errors are accepted.</p> <code>None</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(\n    self,\n    *children: ComponentType,\n    fallback: Component | None = None,\n    errors: Container[type[Exception]] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *children: The wrapped children components.\n        fallback: The fallback component to render in case an error occurs during children rendering.\n        errors: An optional set of accepted error types. Only accepted errors are swallowed and rendered\n            with the fallback. If an error is not in this set but one of its base classes is, then the\n            error will still be accepted and the fallbak rendered. By default all errors are accepted.\n    \"\"\"\n    super().__init__(*children)\n    self._errors = errors\n    self._fallback: Component = \"\" if fallback is None else fallback\n</code></pre>"},{"location":"api/core/#htmy.core.ErrorBoundary.fallback_component","title":"<code>fallback_component(error)</code>","text":"<p>Returns the fallback component for the given error.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The error that occurred during the rendering of the error boundary's subtree.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>The received error if it's not accepted.</p> Source code in <code>htmy/core.py</code> <pre><code>def fallback_component(self, error: Exception) -&gt; ComponentType:\n    \"\"\"\n    Returns the fallback component for the given error.\n\n    Arguments:\n        error: The error that occurred during the rendering of the error boundary's subtree.\n\n    Raises:\n        Exception: The received error if it's not accepted.\n    \"\"\"\n    if not (self._errors is None or any(e in self._errors for e in type(error).mro())):\n        raise error\n\n    return as_component_type(self._fallback)\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter","title":"<code>Formatter</code>","text":"<p>               Bases: <code>ContextAware</code></p> <p>The default, context-aware property name and value formatter.</p> <p>The formatter supports both primitive and (many) complex values, such as lists, dictionaries, tuples, and sets. Complex values are JSON-serialized by default.</p> <p>Important: the default implementation looks up the formatter for a given value by checking its type, but it doesn't do this check with the base classes of the encountered type. For example the formatter will know how to format <code>datetime</code> object, but it won't know how to format a <code>MyCustomDatetime(datetime)</code> instance.</p> <p>One reason for this is efficiency: always checking the base classes of every single value is a lot of unnecessary calculation. The other reason is customizability: this way you could use subclassing for formatter selection, e.g. with <code>LocaleDatetime(datetime)</code>-like classes.</p> <p>Property name and value formatters may raise a <code>SkipProperty</code> error if a property should be skipped.</p> Source code in <code>htmy/core.py</code> <pre><code>class Formatter(ContextAware):\n    \"\"\"\n    The default, context-aware property name and value formatter.\n\n    The formatter supports both primitive and (many) complex values, such as lists,\n    dictionaries, tuples, and sets. Complex values are JSON-serialized by default.\n\n    Important: the default implementation looks up the formatter for a given value by checking\n    its type, but it doesn't do this check with the base classes of the encountered type. For\n    example the formatter will know how to format `datetime` object, but it won't know how to\n    format a `MyCustomDatetime(datetime)` instance.\n\n    One reason for this is efficiency: always checking the base classes of every single value is a\n    lot of unnecessary calculation. The other reason is customizability: this way you could use\n    subclassing for formatter selection, e.g. with `LocaleDatetime(datetime)`-like classes.\n\n    Property name and value formatters may raise a `SkipProperty` error if a property should be skipped.\n    \"\"\"\n\n    __slots__ = (\"_default_formatter\", \"_name_formatter\", \"_value_formatters\")\n\n    def __init__(\n        self,\n        *,\n        default_formatter: Callable[[Any], str] = str,\n        name_formatter: Callable[[str], str] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            default_formatter: The default property value formatter to use if no formatter could\n                be found for a given value.\n            name_formatter: Optional property name formatter (for replacing the default name formatter).\n        \"\"\"\n        super().__init__()\n        self._default_formatter = default_formatter\n        self._name_formatter = self._format_name if name_formatter is None else name_formatter\n        self._value_formatters: dict[type, Callable[[Any], str]] = self._base_formatters()\n\n    def add(self, key: type[T], formatter: Callable[[T], str]) -&gt; Self:\n        \"\"\"Registers the given value formatter under the given key.\"\"\"\n        self._value_formatters[key] = formatter\n        return self\n\n    def format(self, name: str, value: Any) -&gt; str:\n        \"\"\"\n        Formats the given name-value pair.\n\n        Returns an empty string if the property name or value should be skipped.\n\n        See `SkipProperty` for more information.\n        \"\"\"\n        try:\n            return f\"{self.format_name(name)}={xml_quoteattr(self.format_value(value))}\"\n        except SkipProperty:\n            return \"\"\n\n    def format_name(self, name: str) -&gt; str:\n        \"\"\"\n        Formats the given name.\n\n        Raises:\n            SkipProperty: If the property should be skipped.\n        \"\"\"\n        return self._name_formatter(name)\n\n    def format_value(self, value: Any) -&gt; str:\n        \"\"\"\n        Formats the given value.\n\n        Arguments:\n            value: The property value to format.\n\n        Raises:\n            SkipProperty: If the property should be skipped.\n        \"\"\"\n        fmt = self._value_formatters.get(type(value), self._default_formatter)\n        return fmt(value)\n\n    def _format_name(self, name: str, /) -&gt; str:\n        \"\"\"The default property name formatter.\"\"\"\n        no_replacement = \"_\" in {name[0], name[-1]}\n        return name.strip(\"_\") if no_replacement else name.replace(\"_\", \"-\")\n\n    def _base_formatters(self) -&gt; dict[type, Callable[[Any], str]]:\n        \"\"\"Factory that creates the default value formatter mapping.\"\"\"\n        from datetime import date, datetime\n\n        return {\n            bool: lambda v: \"true\" if v else \"false\",\n            date: lambda d: cast(date, d).isoformat(),\n            datetime: lambda d: cast(datetime, d).isoformat(),\n            dict: lambda v: json.dumps(v),\n            list: lambda v: json.dumps(v),\n            tuple: lambda v: json.dumps(v),\n            set: lambda v: json.dumps(tuple(v)),\n            XBool: lambda v: cast(XBool, v).format(),\n            type(None): SkipProperty.format_property,\n        }\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter.__init__","title":"<code>__init__(*, default_formatter=str, name_formatter=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>default_formatter</code> <code>Callable[[Any], str]</code> <p>The default property value formatter to use if no formatter could be found for a given value.</p> <code>str</code> <code>name_formatter</code> <code>Callable[[str], str] | None</code> <p>Optional property name formatter (for replacing the default name formatter).</p> <code>None</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(\n    self,\n    *,\n    default_formatter: Callable[[Any], str] = str,\n    name_formatter: Callable[[str], str] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        default_formatter: The default property value formatter to use if no formatter could\n            be found for a given value.\n        name_formatter: Optional property name formatter (for replacing the default name formatter).\n    \"\"\"\n    super().__init__()\n    self._default_formatter = default_formatter\n    self._name_formatter = self._format_name if name_formatter is None else name_formatter\n    self._value_formatters: dict[type, Callable[[Any], str]] = self._base_formatters()\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter.add","title":"<code>add(key, formatter)</code>","text":"<p>Registers the given value formatter under the given key.</p> Source code in <code>htmy/core.py</code> <pre><code>def add(self, key: type[T], formatter: Callable[[T], str]) -&gt; Self:\n    \"\"\"Registers the given value formatter under the given key.\"\"\"\n    self._value_formatters[key] = formatter\n    return self\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter.format","title":"<code>format(name, value)</code>","text":"<p>Formats the given name-value pair.</p> <p>Returns an empty string if the property name or value should be skipped.</p> <p>See <code>SkipProperty</code> for more information.</p> Source code in <code>htmy/core.py</code> <pre><code>def format(self, name: str, value: Any) -&gt; str:\n    \"\"\"\n    Formats the given name-value pair.\n\n    Returns an empty string if the property name or value should be skipped.\n\n    See `SkipProperty` for more information.\n    \"\"\"\n    try:\n        return f\"{self.format_name(name)}={xml_quoteattr(self.format_value(value))}\"\n    except SkipProperty:\n        return \"\"\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter.format_name","title":"<code>format_name(name)</code>","text":"<p>Formats the given name.</p> <p>Raises:</p> Type Description <code>SkipProperty</code> <p>If the property should be skipped.</p> Source code in <code>htmy/core.py</code> <pre><code>def format_name(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the given name.\n\n    Raises:\n        SkipProperty: If the property should be skipped.\n    \"\"\"\n    return self._name_formatter(name)\n</code></pre>"},{"location":"api/core/#htmy.core.Formatter.format_value","title":"<code>format_value(value)</code>","text":"<p>Formats the given value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The property value to format.</p> required <p>Raises:</p> Type Description <code>SkipProperty</code> <p>If the property should be skipped.</p> Source code in <code>htmy/core.py</code> <pre><code>def format_value(self, value: Any) -&gt; str:\n    \"\"\"\n    Formats the given value.\n\n    Arguments:\n        value: The property value to format.\n\n    Raises:\n        SkipProperty: If the property should be skipped.\n    \"\"\"\n    fmt = self._value_formatters.get(type(value), self._default_formatter)\n    return fmt(value)\n</code></pre>"},{"location":"api/core/#htmy.core.Fragment","title":"<code>Fragment</code>","text":"<p>Fragment utility component that simply wraps some children components.</p> Source code in <code>htmy/core.py</code> <pre><code>class Fragment:\n    \"\"\"Fragment utility component that simply wraps some children components.\"\"\"\n\n    __slots__ = (\"_children\",)\n\n    def __init__(self, *children: ComponentType) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *children: The wrapped children.\n        \"\"\"\n        self._children = children\n\n    def htmy(self, context: Context) -&gt; Component:\n        \"\"\"Renders the component.\"\"\"\n        return self._children\n</code></pre>"},{"location":"api/core/#htmy.core.Fragment.__init__","title":"<code>__init__(*children)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <code>ComponentType</code> <p>The wrapped children.</p> <code>()</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(self, *children: ComponentType) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *children: The wrapped children.\n    \"\"\"\n    self._children = children\n</code></pre>"},{"location":"api/core/#htmy.core.Fragment.htmy","title":"<code>htmy(context)</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/core.py</code> <pre><code>def htmy(self, context: Context) -&gt; Component:\n    \"\"\"Renders the component.\"\"\"\n    return self._children\n</code></pre>"},{"location":"api/core/#htmy.core.SafeStr","title":"<code>SafeStr</code>","text":"<p>               Bases: <code>Text</code></p> <p>String subclass whose instances shouldn't get escaped during rendering.</p> <p>Note: any operation on <code>SafeStr</code> instances will result in plain <code>str</code> instances which will be rendered normally. Make sure the <code>str</code> to <code>SafeStr</code> conversion (<code>SafeStr(my_string)</code>) takes when there's no string operation afterwards.</p> Source code in <code>htmy/core.py</code> <pre><code>class SafeStr(Text):\n    \"\"\"\n    String subclass whose instances shouldn't get escaped during rendering.\n\n    Note: any operation on `SafeStr` instances will result in plain `str` instances which\n    will be rendered normally. Make sure the `str` to `SafeStr` conversion (`SafeStr(my_string)`)\n    takes when there's no string operation afterwards.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"api/core/#htmy.core.SkipProperty","title":"<code>SkipProperty</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised by property formatters if the property should be skipped.</p> Source code in <code>htmy/core.py</code> <pre><code>class SkipProperty(Exception):\n    \"\"\"Exception raised by property formatters if the property should be skipped.\"\"\"\n\n    ...\n\n    @classmethod\n    def format_property(cls, _: Any) -&gt; Never:\n        \"\"\"Property formatter that raises a `SkipProperty` error regardless of the received value.\"\"\"\n        raise cls(\"skip-property\")\n</code></pre>"},{"location":"api/core/#htmy.core.SkipProperty.format_property","title":"<code>format_property(_)</code>  <code>classmethod</code>","text":"<p>Property formatter that raises a <code>SkipProperty</code> error regardless of the received value.</p> Source code in <code>htmy/core.py</code> <pre><code>@classmethod\ndef format_property(cls, _: Any) -&gt; Never:\n    \"\"\"Property formatter that raises a `SkipProperty` error regardless of the received value.\"\"\"\n    raise cls(\"skip-property\")\n</code></pre>"},{"location":"api/core/#htmy.core.Tag","title":"<code>Tag</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p>Base class for tags with both properties and children.</p> Source code in <code>htmy/core.py</code> <pre><code>class Tag(TagWithProps):\n    \"\"\"Base class for tags with both properties and children.\"\"\"\n\n    __slots__ = (\"children\",)\n\n    tag_config: TagConfig = {\"child_separator\": \"\\n\"}\n\n    def __init__(self, *children: ComponentType, **props: PropertyValue) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *children: Children components.\n            **props: Tag properties.\n        \"\"\"\n        super().__init__(**props)\n        self.children = children\n\n    @property\n    def child_separator(self) -&gt; ComponentType | None:\n        \"\"\"The child separator to use.\"\"\"\n        return self.tag_config.get(\"child_separator\", None)\n\n    def htmy(self, context: Context) -&gt; Component:\n        \"\"\"Renders the component.\"\"\"\n        name = self.htmy_name\n        props = self._htmy_format_props(context=context)\n        opening, closing = SafeStr(f\"&lt;{name} {props}&gt;\"), SafeStr(f\"&lt;/{name}&gt;\")\n        separator = self.child_separator\n        return (\n            opening,\n            *(\n                self.children\n                if separator is None\n                else join_components(self.children, separator=separator, pad=True)\n            ),\n            closing,\n        )\n</code></pre>"},{"location":"api/core/#htmy.core.Tag.child_separator","title":"<code>child_separator</code>  <code>property</code>","text":"<p>The child separator to use.</p>"},{"location":"api/core/#htmy.core.Tag.__init__","title":"<code>__init__(*children, **props)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <code>ComponentType</code> <p>Children components.</p> <code>()</code> <code>**props</code> <code>PropertyValue</code> <p>Tag properties.</p> <code>{}</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(self, *children: ComponentType, **props: PropertyValue) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *children: Children components.\n        **props: Tag properties.\n    \"\"\"\n    super().__init__(**props)\n    self.children = children\n</code></pre>"},{"location":"api/core/#htmy.core.Tag.htmy","title":"<code>htmy(context)</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/core.py</code> <pre><code>def htmy(self, context: Context) -&gt; Component:\n    \"\"\"Renders the component.\"\"\"\n    name = self.htmy_name\n    props = self._htmy_format_props(context=context)\n    opening, closing = SafeStr(f\"&lt;{name} {props}&gt;\"), SafeStr(f\"&lt;/{name}&gt;\")\n    separator = self.child_separator\n    return (\n        opening,\n        *(\n            self.children\n            if separator is None\n            else join_components(self.children, separator=separator, pad=True)\n        ),\n        closing,\n    )\n</code></pre>"},{"location":"api/core/#htmy.core.TagConfig","title":"<code>TagConfig</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Tag configuration.</p> Source code in <code>htmy/core.py</code> <pre><code>class TagConfig(TypedDict, total=False):\n    \"\"\"Tag configuration.\"\"\"\n\n    child_separator: ComponentType | None\n</code></pre>"},{"location":"api/core/#htmy.core.TagWithProps","title":"<code>TagWithProps</code>","text":"<p>               Bases: <code>BaseTag</code></p> <p>Base class for tags with properties.</p> Source code in <code>htmy/core.py</code> <pre><code>class TagWithProps(BaseTag):\n    \"\"\"Base class for tags with properties.\"\"\"\n\n    __slots__ = (\"props\",)\n\n    def __init__(self, **props: PropertyValue) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            **props: Tag properties.\n        \"\"\"\n        super().__init__()\n        self.props = props\n\n    def htmy(self, context: Context) -&gt; Component:\n        \"\"\"Renders the component.\"\"\"\n        name = self.htmy_name\n        props = self._htmy_format_props(context=context)\n        return SafeStr(f\"&lt;{name} {props}/&gt;\")\n\n    def _htmy_format_props(self, context: Context) -&gt; str:\n        \"\"\"Formats tag properties.\"\"\"\n        formatter = Formatter.from_context(context, _default_tag_formatter)\n        return \" \".join(formatter.format(name, value) for name, value in self.props.items())\n</code></pre>"},{"location":"api/core/#htmy.core.TagWithProps.__init__","title":"<code>__init__(**props)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>**props</code> <code>PropertyValue</code> <p>Tag properties.</p> <code>{}</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(self, **props: PropertyValue) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        **props: Tag properties.\n    \"\"\"\n    super().__init__()\n    self.props = props\n</code></pre>"},{"location":"api/core/#htmy.core.TagWithProps.htmy","title":"<code>htmy(context)</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/core.py</code> <pre><code>def htmy(self, context: Context) -&gt; Component:\n    \"\"\"Renders the component.\"\"\"\n    name = self.htmy_name\n    props = self._htmy_format_props(context=context)\n    return SafeStr(f\"&lt;{name} {props}/&gt;\")\n</code></pre>"},{"location":"api/core/#htmy.core.Text","title":"<code>Text</code>","text":"<p>               Bases: <code>str</code></p> <p>Marker class for differentiating text content from other strings.</p> Source code in <code>htmy/core.py</code> <pre><code>class Text(str):\n    \"\"\"Marker class for differentiating text content from other strings.\"\"\"\n\n    ...\n</code></pre>"},{"location":"api/core/#htmy.core.WildcardTag","title":"<code>WildcardTag</code>","text":"<p>               Bases: <code>Tag</code></p> <p>Tag that can have both children and properties, and whose tag name can be set.</p> Source code in <code>htmy/core.py</code> <pre><code>class WildcardTag(Tag):\n    \"\"\"Tag that can have both children and properties, and whose tag name can be set.\"\"\"\n\n    __slots__ = (\"_child_separator\",)\n\n    def __init__(\n        self,\n        *children: ComponentType,\n        htmy_name: str,\n        htmy_child_separator: ComponentType | None = None,\n        **props: PropertyValue,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *children: Children components.\n            htmy_name: The tag name to use for this tag.\n            htmy_child_separator: The child separator to use (if any).\n            **props: Tag properties.\n        \"\"\"\n        super().__init__(*children, **props)\n        self._htmy_name = htmy_name\n        self._child_separator = htmy_child_separator\n\n    @property\n    def child_separator(self) -&gt; ComponentType | None:\n        return self._child_separator\n</code></pre>"},{"location":"api/core/#htmy.core.WildcardTag.__init__","title":"<code>__init__(*children, htmy_name, htmy_child_separator=None, **props)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <code>ComponentType</code> <p>Children components.</p> <code>()</code> <code>htmy_name</code> <code>str</code> <p>The tag name to use for this tag.</p> required <code>htmy_child_separator</code> <code>ComponentType | None</code> <p>The child separator to use (if any).</p> <code>None</code> <code>**props</code> <code>PropertyValue</code> <p>Tag properties.</p> <code>{}</code> Source code in <code>htmy/core.py</code> <pre><code>def __init__(\n    self,\n    *children: ComponentType,\n    htmy_name: str,\n    htmy_child_separator: ComponentType | None = None,\n    **props: PropertyValue,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *children: Children components.\n        htmy_name: The tag name to use for this tag.\n        htmy_child_separator: The child separator to use (if any).\n        **props: Tag properties.\n    \"\"\"\n    super().__init__(*children, **props)\n    self._htmy_name = htmy_name\n    self._child_separator = htmy_child_separator\n</code></pre>"},{"location":"api/core/#htmy.core.WithContext","title":"<code>WithContext</code>","text":"<p>               Bases: <code>Fragment</code></p> <p>A simple, static context provider component.</p> Source code in <code>htmy/core.py</code> <pre><code>class WithContext(Fragment):\n    \"\"\"\n    A simple, static context provider component.\n    \"\"\"\n\n    __slots__ = (\"_context\",)\n\n    def __init__(self, *children: ComponentType, context: Context) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            *children: The children components to wrap in the given context.\n            context: The context to make available to children components.\n        \"\"\"\n        super().__init__(*children)\n        self._context = context\n\n    def htmy_context(self) -&gt; Context:\n        \"\"\"Returns the context for child rendering.\"\"\"\n        return self._context\n</code></pre>"},{"location":"api/core/#htmy.core.WithContext.__init__","title":"<code>__init__(*children, context)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <code>ComponentType</code> <p>The children components to wrap in the given context.</p> <code>()</code> <code>context</code> <code>Context</code> <p>The context to make available to children components.</p> required Source code in <code>htmy/core.py</code> <pre><code>def __init__(self, *children: ComponentType, context: Context) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        *children: The children components to wrap in the given context.\n        context: The context to make available to children components.\n    \"\"\"\n    super().__init__(*children)\n    self._context = context\n</code></pre>"},{"location":"api/core/#htmy.core.WithContext.htmy_context","title":"<code>htmy_context()</code>","text":"<p>Returns the context for child rendering.</p> Source code in <code>htmy/core.py</code> <pre><code>def htmy_context(self) -&gt; Context:\n    \"\"\"Returns the context for child rendering.\"\"\"\n    return self._context\n</code></pre>"},{"location":"api/core/#htmy.core.XBool","title":"<code>XBool</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Utility for the valid formatting of boolean XML (and HTML) attributes.</p> <p>See this article for more information: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#boolean_attributes</p> Source code in <code>htmy/core.py</code> <pre><code>class XBool(enum.Enum):\n    \"\"\"\n    Utility for the valid formatting of boolean XML (and HTML) attributes.\n\n    See this article for more information:\n    https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#boolean_attributes\n    \"\"\"\n\n    true = True\n    false = False\n\n    def format(self) -&gt; str:\n        \"\"\"\n        Raises `SkipProperty` for `XBool.false`, returns empty string for `XBool.true`.\n        \"\"\"\n        if self is XBool.true:\n            return \"\"\n\n        raise SkipProperty()\n</code></pre>"},{"location":"api/core/#htmy.core.XBool.format","title":"<code>format()</code>","text":"<p>Raises <code>SkipProperty</code> for <code>XBool.false</code>, returns empty string for <code>XBool.true</code>.</p> Source code in <code>htmy/core.py</code> <pre><code>def format(self) -&gt; str:\n    \"\"\"\n    Raises `SkipProperty` for `XBool.false`, returns empty string for `XBool.true`.\n    \"\"\"\n    if self is XBool.true:\n        return \"\"\n\n    raise SkipProperty()\n</code></pre>"},{"location":"api/core/#htmy.core.xml_format_string","title":"<code>xml_format_string(value)</code>","text":"<p>Escapes <code>&lt;</code>, <code>&gt;</code>, and <code>&amp;</code> characters in the given string, unless it's a <code>SafeStr</code>.</p> Source code in <code>htmy/core.py</code> <pre><code>def xml_format_string(value: str) -&gt; str:\n    \"\"\"Escapes `&lt;`, `&gt;`, and `&amp;` characters in the given string, unless it's a `SafeStr`.\"\"\"\n    return value if isinstance(value, SafeStr) else xml_escape(value)\n</code></pre>"},{"location":"api/etree/","title":"Etree","text":""},{"location":"api/etree/#htmy.etree","title":"<code>htmy.etree</code>","text":""},{"location":"api/etree/#htmy.etree.ETreeConverter","title":"<code>ETreeConverter</code>","text":"<p>Utility for converting XML strings to custom components.</p> <p>By default the converter uses the standard library's <code>xml.etree.ElementTree</code> module for string to element tree, and element tree to string conversion, but if <code>lxml</code> is installed, it will be used instead.</p> <p>Installing <code>lxml</code> is recommended for better performance and additional features, like performance and support for broken HTML fragments. Important: <code>lxml</code> is far more lenient and flexible than the standard library, so having it installed is not only a performance boost, but it may also slightly change the element conversion behavior in certain edge-cases!</p> Source code in <code>htmy/etree.py</code> <pre><code>class ETreeConverter:\n    \"\"\"\n    Utility for converting XML strings to custom components.\n\n    By default the converter uses the standard library's `xml.etree.ElementTree`\n    module for string to element tree, and element tree to string conversion,\n    but if `lxml` is installed, it will be used instead.\n\n    Installing `lxml` is recommended for better performance and additional features,\n    like performance and support for broken HTML fragments. **Important:** `lxml` is\n    far more lenient and flexible than the standard library, so having it installed is\n    not only a performance boost, but it may also slightly change the element conversion\n    behavior in certain edge-cases!\n    \"\"\"\n\n    __slots__ = (\"_rules\",)\n\n    _htmy_fragment: ClassVar[str] = \"htmy_fragment\"\n    \"\"\"\n    Placeholder tag name that's used to wrap possibly multi-root XML snippets into a valid\n    XML document with a single root that can be processed by standard tools.\n    \"\"\"\n\n    def __init__(self, rules: Mapping[str, Callable[..., ComponentType]]) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            rules: Tag-name to component conversion rules.\n        \"\"\"\n        self._rules = rules\n\n    def convert(self, element: str) -&gt; ComponentType:\n        \"\"\"Converts the given (possibly multi-root) XML string to a component.\"\"\"\n        if len(self._rules) == 0:\n            return SafeStr(element)\n\n        element = f\"&lt;{self._htmy_fragment}&gt;{element}&lt;/{self._htmy_fragment}&gt;\"\n        return self.convert_element(etree_from_string(element))  # noqa: S314 # Only use XML strings from a trusted source.\n\n    def convert_element(self, element: Element) -&gt; ComponentType:\n        \"\"\"Converts the given `Element` to a component.\"\"\"\n        rules = self._rules\n        if len(rules) == 0:\n            return SafeStr(etree_to_string(element, encoding=\"unicode\"))\n\n        tag: str = element.tag  # type: ignore[assignment]\n        component = Fragment if tag == self._htmy_fragment else rules.get(tag)\n        children = self._convert_children(element)\n        properties = self._convert_properties(element)\n\n        return (\n            WildcardTag(*children, htmy_name=tag, **properties)\n            if component is None\n            else component(\n                *children,\n                **properties,\n            )\n        )\n\n    def _convert_properties(self, element: Element) -&gt; Properties:\n        \"\"\"\n        Converts the attributes of the given `Element` to a `Properties` mapping.\n\n        This method should not alter property names in any way.\n        \"\"\"\n        return {key: unescape(value) for key, value in element.items()}\n\n    def _convert_children(self, element: Element) -&gt; Generator[ComponentType, None, None]:\n        \"\"\"\n        Generator that converts all (text and `Element`) children of the given `Element` to a component.\n        \"\"\"\n        if text := self._process_text(element.text):\n            yield text\n\n        for child in element:\n            yield self.convert_element(child)\n            if tail := self._process_text(child.tail):\n                yield tail\n\n    def _process_text(self, escaped_text: str | None) -&gt; str | None:\n        \"\"\"Processes a single XML-escaped text child.\"\"\"\n        return unescape(escaped_text) if escaped_text else None\n</code></pre>"},{"location":"api/etree/#htmy.etree.ETreeConverter.__init__","title":"<code>__init__(rules)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>Mapping[str, Callable[..., ComponentType]]</code> <p>Tag-name to component conversion rules.</p> required Source code in <code>htmy/etree.py</code> <pre><code>def __init__(self, rules: Mapping[str, Callable[..., ComponentType]]) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        rules: Tag-name to component conversion rules.\n    \"\"\"\n    self._rules = rules\n</code></pre>"},{"location":"api/etree/#htmy.etree.ETreeConverter.convert","title":"<code>convert(element)</code>","text":"<p>Converts the given (possibly multi-root) XML string to a component.</p> Source code in <code>htmy/etree.py</code> <pre><code>def convert(self, element: str) -&gt; ComponentType:\n    \"\"\"Converts the given (possibly multi-root) XML string to a component.\"\"\"\n    if len(self._rules) == 0:\n        return SafeStr(element)\n\n    element = f\"&lt;{self._htmy_fragment}&gt;{element}&lt;/{self._htmy_fragment}&gt;\"\n    return self.convert_element(etree_from_string(element))  # noqa: S314 # Only use XML strings from a trusted source.\n</code></pre>"},{"location":"api/etree/#htmy.etree.ETreeConverter.convert_element","title":"<code>convert_element(element)</code>","text":"<p>Converts the given <code>Element</code> to a component.</p> Source code in <code>htmy/etree.py</code> <pre><code>def convert_element(self, element: Element) -&gt; ComponentType:\n    \"\"\"Converts the given `Element` to a component.\"\"\"\n    rules = self._rules\n    if len(rules) == 0:\n        return SafeStr(etree_to_string(element, encoding=\"unicode\"))\n\n    tag: str = element.tag  # type: ignore[assignment]\n    component = Fragment if tag == self._htmy_fragment else rules.get(tag)\n    children = self._convert_children(element)\n    properties = self._convert_properties(element)\n\n    return (\n        WildcardTag(*children, htmy_name=tag, **properties)\n        if component is None\n        else component(\n            *children,\n            **properties,\n        )\n    )\n</code></pre>"},{"location":"api/function_component/","title":"Function component","text":""},{"location":"api/function_component/#htmy.function_component","title":"<code>htmy.function_component</code>","text":""},{"location":"api/function_component/#htmy.function_component.component","title":"<code>component = ComponentDecorators()</code>  <code>module-attribute</code>","text":"<p>Decorators for converting functions into components</p> <p>This is an instance of <code>ComponentDecorators</code>.</p>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators","title":"<code>ComponentDecorators</code>","text":"<p>Function component decorators.</p> Source code in <code>htmy/function_component.py</code> <pre><code>class ComponentDecorators:\n    \"\"\"\n    Function component decorators.\n    \"\"\"\n\n    __slots__ = ()\n\n    # -- Function component decorator.\n\n    @overload\n    def __call__(self, func: _SyncFunctionComponent[TProps]) -&gt; Callable[[TProps], SyncComponent]: ...\n\n    @overload\n    def __call__(self, func: _AsyncFunctionComponent[TProps]) -&gt; Callable[[TProps], AsyncComponent]: ...\n\n    def __call__(\n        self,\n        func: _SyncFunctionComponent[TProps] | _AsyncFunctionComponent[TProps],\n    ) -&gt; Callable[[TProps], SyncComponent] | Callable[[TProps], AsyncComponent]:\n        \"\"\"\n        Decorator that converts the decorated function into one that must be called with\n        the function component's properties and returns a component instance.\n\n        If used on an async function, the resulting component will also be async;\n        otherwise it will be sync.\n\n        Example:\n\n        ```python\n        @component\n        def my_component(props: int, context: Context) -&gt; Component:\n            return html.p(f\"Value: {props}\")\n\n        async def render() -&gt; str:\n           return await Renderer().render(\n               my_component(42)\n           )\n        ```\n\n        Arguments:\n            func: The decorated function.\n\n        Returns:\n            A function that must be called with the function component's properties and\n            returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n            can be \"instantiated\" with the function component's properties.)\n        \"\"\"\n\n        if asyncio.iscoroutinefunction(func):\n\n            def async_wrapper(props: TProps) -&gt; AsyncComponent:\n                # This function must be async, in case the renderer inspects it to decide how to handle it.\n                async def component(context: Context) -&gt; Component:\n                    return await func(props, context)  # type: ignore[no-any-return]\n\n                component.htmy = component  # type: ignore[attr-defined]\n                return component  # type: ignore[return-value]\n\n            return async_wrapper\n        else:\n\n            def sync_wrapper(props: TProps) -&gt; SyncComponent:\n                def component(context: Context) -&gt; Component:\n                    return func(props, context)  # type: ignore[return-value]\n\n                component.htmy = component  # type: ignore[attr-defined]\n                return component  # type: ignore[return-value]\n\n            return sync_wrapper\n\n    @overload\n    def function(self, func: _SyncFunctionComponent[TProps]) -&gt; Callable[[TProps], SyncComponent]: ...\n\n    @overload\n    def function(self, func: _AsyncFunctionComponent[TProps]) -&gt; Callable[[TProps], AsyncComponent]: ...\n\n    def function(\n        self,\n        func: _SyncFunctionComponent[TProps] | _AsyncFunctionComponent[TProps],\n    ) -&gt; Callable[[TProps], SyncComponent] | Callable[[TProps], AsyncComponent]:\n        \"\"\"\n        Decorator that converts the decorated function into one that must be called with\n        the function component's properties and returns a component instance.\n\n        If used on an async function, the resulting component will also be async;\n        otherwise it will be sync.\n\n        This function is just an alias for `__call__()`.\n\n        Example:\n\n        ```python\n        @component.function\n        def my_component(props: int, context: Context) -&gt; Component:\n            return html.p(f\"Value: {props}\")\n\n        async def render() -&gt; str:\n           return await Renderer().render(\n               my_component(42)\n           )\n\n        Arguments:\n            func: The decorated function.\n\n        Returns:\n            A function that must be called with the function component's properties and\n            returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n            can be \"instantiated\" with the function component's properties.)\n        \"\"\"\n        return self(func)\n\n    # -- Context-only function component decorator.\n\n    @overload\n    def context_only(\n        self, func: _ContextOnlySyncFunctionComponent\n    ) -&gt; _DecoratedContextOnlySyncFunctionComponent: ...\n\n    @overload\n    def context_only(\n        self, func: _ContextOnlyAsyncFunctionComponent\n    ) -&gt; _DecoratedContextOnlyAsyncFunctionComponent: ...\n\n    def context_only(\n        self,\n        func: _ContextOnlySyncFunctionComponent | _ContextOnlyAsyncFunctionComponent,\n    ) -&gt; _DecoratedContextOnlySyncFunctionComponent | _DecoratedContextOnlyAsyncFunctionComponent:\n        \"\"\"\n        Decorator that converts the decorated function into a component.\n\n        If used on an async function, the resulting component will also be async;\n        otherwise it will be sync.\n\n        Example:\n\n        ```python\n        @component.context_only\n        def my_component(ctx):\n            return \"Context only function component.\"\n\n        async def render() -&gt; str:\n           return await Renderer().render(\n               my_component()\n           )\n        ```\n\n        Arguments:\n            func: The decorated function.\n\n        Returns:\n            The created component.\n        \"\"\"\n\n        def wrapper() -&gt; SyncComponent | AsyncComponent:\n            func.htmy = func  # type: ignore[union-attr]\n            return func  # type: ignore[return-value]\n\n        # This assignment adds support for context-only function components without call signature.\n        wrapper.htmy = func  # type: ignore[attr-defined]\n        return wrapper  # type: ignore[return-value]\n\n    # -- Method component decorator.\n\n    @overload\n    def method(\n        self, func: _SyncMethodComponent[TSelf, TProps]\n    ) -&gt; Callable[[TSelf, TProps], SyncComponent]: ...\n\n    @overload\n    def method(\n        self, func: _AsyncMethodComponent[TSelf, TProps]\n    ) -&gt; Callable[[TSelf, TProps], AsyncComponent]: ...\n\n    def method(\n        self,\n        func: _SyncMethodComponent[TSelf, TProps] | _AsyncMethodComponent[TSelf, TProps],\n    ) -&gt; Callable[[TSelf, TProps], SyncComponent] | Callable[[TSelf, TProps], AsyncComponent]:\n        \"\"\"\n        Decorator that converts the decorated method into one that must be called with\n        the method component's properties and returns a component instance.\n\n        If used on an async method, the resulting component will also be async;\n        otherwise it will be sync.\n\n        Example:\n\n        ```python\n        @dataclass\n        class MyBusinessObject:\n            message: str\n\n            @component.method\n            def paragraph(self, props: int, context: Context) -&gt; Component:\n                return html.p(f\"{self.message} {props}\")\n\n\n        async def render() -&gt; str:\n            return await Renderer().render(\n                MyBusinessObject(\"Hi!\").paragraph(42)\n            )\n        ```\n\n        Arguments:\n            func: The decorated method.\n\n        Returns:\n            A method that must be called with the method component's properties and\n            returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n            can be \"instantiated\" with the method component's properties.)\n        \"\"\"\n        if asyncio.iscoroutinefunction(func):\n\n            def async_wrapper(self: TSelf, props: TProps) -&gt; AsyncComponent:\n                # This function must be async, in case the renderer inspects it to decide how to handle it.\n                async def component(context: Context) -&gt; Component:\n                    return await func(self, props, context)  # type: ignore[no-any-return]\n\n                component.htmy = component  # type: ignore[attr-defined]\n                return component  # type: ignore[return-value]\n\n            return async_wrapper\n        else:\n\n            def sync_wrapper(self: TSelf, props: TProps) -&gt; SyncComponent:\n                def component(context: Context) -&gt; Component:\n                    return func(self, props, context)  # type: ignore[return-value]\n\n                component.htmy = component  # type: ignore[attr-defined]\n                return component  # type: ignore[return-value]\n\n            return sync_wrapper\n\n    # -- Context-only function component decorator.\n\n    @overload\n    def context_only_method(\n        self, func: _SyncFunctionComponent[TSelf]\n    ) -&gt; Callable[[TSelf], SyncComponent]: ...\n\n    @overload\n    def context_only_method(\n        self, func: _AsyncFunctionComponent[TSelf]\n    ) -&gt; Callable[[TSelf], AsyncComponent]: ...\n\n    def context_only_method(\n        self,\n        func: _SyncFunctionComponent[TSelf] | _AsyncFunctionComponent[TSelf],\n    ) -&gt; Callable[[TSelf], SyncComponent] | Callable[[TSelf], AsyncComponent]:\n        \"\"\"\n        Decorator that converts the decorated method into one that must be called\n        without any arguments and returns a component instance.\n\n        If used on an async method, the resulting component will also be async;\n        otherwise it will be sync.\n\n        Example:\n\n        ```python\n        @dataclass\n        class MyBusinessObject:\n            message: str\n\n            @component.context_only_method\n            def paragraph(self, context: Context) -&gt; Component:\n                return html.p(f\"{self.message} Goodbye!\")\n\n\n        async def render() -&gt; str:\n            return await Renderer().render(\n                MyBusinessObject(\"Hello!\").paragraph()\n            )\n        ```\n\n        Arguments:\n            func: The decorated method.\n\n        Returns:\n            A method that must be called without any arguments and returns a component instance.\n            (Or loosly speaking, an `HTMYComponentType` which can be \"instantiated\" by calling\n            the method.)\n        \"\"\"\n        # A context only method component must be implemented in the same way as\n        # a function component. The self argument replaces the props argument\n        # and it is added automatically by Python when the method is called.\n        # Even the type hint must be the same.\n        # This implementation doesn't make the function itself a component though,\n        # so the call signature is always necessary (unlike for context-only function\n        # components).\n        return self(func)\n</code></pre>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators.__call__","title":"<code>__call__(func)</code>","text":"<pre><code>__call__(func: _SyncFunctionComponent[TProps]) -&gt; Callable[[TProps], SyncComponent]\n</code></pre><pre><code>__call__(func: _AsyncFunctionComponent[TProps]) -&gt; Callable[[TProps], AsyncComponent]\n</code></pre> <p>Decorator that converts the decorated function into one that must be called with the function component's properties and returns a component instance.</p> <p>If used on an async function, the resulting component will also be async; otherwise it will be sync.</p> <p>Example:</p> <pre><code>@component\ndef my_component(props: int, context: Context) -&gt; Component:\n    return html.p(f\"Value: {props}\")\n\nasync def render() -&gt; str:\n   return await Renderer().render(\n       my_component(42)\n   )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>_SyncFunctionComponent[T] | _AsyncFunctionComponent[T]</code> <p>The decorated function.</p> required <p>Returns:</p> Type Description <code>Callable[[T], SyncComponent] | Callable[[T], AsyncComponent]</code> <p>A function that must be called with the function component's properties and</p> <code>Callable[[T], SyncComponent] | Callable[[T], AsyncComponent]</code> <p>returns a component instance. (Or loosly speaking, an <code>HTMYComponentType</code> which</p> <code>Callable[[T], SyncComponent] | Callable[[T], AsyncComponent]</code> <p>can be \"instantiated\" with the function component's properties.)</p> Source code in <code>htmy/function_component.py</code> <pre><code>def __call__(\n    self,\n    func: _SyncFunctionComponent[TProps] | _AsyncFunctionComponent[TProps],\n) -&gt; Callable[[TProps], SyncComponent] | Callable[[TProps], AsyncComponent]:\n    \"\"\"\n    Decorator that converts the decorated function into one that must be called with\n    the function component's properties and returns a component instance.\n\n    If used on an async function, the resulting component will also be async;\n    otherwise it will be sync.\n\n    Example:\n\n    ```python\n    @component\n    def my_component(props: int, context: Context) -&gt; Component:\n        return html.p(f\"Value: {props}\")\n\n    async def render() -&gt; str:\n       return await Renderer().render(\n           my_component(42)\n       )\n    ```\n\n    Arguments:\n        func: The decorated function.\n\n    Returns:\n        A function that must be called with the function component's properties and\n        returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n        can be \"instantiated\" with the function component's properties.)\n    \"\"\"\n\n    if asyncio.iscoroutinefunction(func):\n\n        def async_wrapper(props: TProps) -&gt; AsyncComponent:\n            # This function must be async, in case the renderer inspects it to decide how to handle it.\n            async def component(context: Context) -&gt; Component:\n                return await func(props, context)  # type: ignore[no-any-return]\n\n            component.htmy = component  # type: ignore[attr-defined]\n            return component  # type: ignore[return-value]\n\n        return async_wrapper\n    else:\n\n        def sync_wrapper(props: TProps) -&gt; SyncComponent:\n            def component(context: Context) -&gt; Component:\n                return func(props, context)  # type: ignore[return-value]\n\n            component.htmy = component  # type: ignore[attr-defined]\n            return component  # type: ignore[return-value]\n\n        return sync_wrapper\n</code></pre>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators.context_only","title":"<code>context_only(func)</code>","text":"<pre><code>context_only(func: _ContextOnlySyncFunctionComponent) -&gt; _DecoratedContextOnlySyncFunctionComponent\n</code></pre><pre><code>context_only(func: _ContextOnlyAsyncFunctionComponent) -&gt; _DecoratedContextOnlyAsyncFunctionComponent\n</code></pre> <p>Decorator that converts the decorated function into a component.</p> <p>If used on an async function, the resulting component will also be async; otherwise it will be sync.</p> <p>Example:</p> <pre><code>@component.context_only\ndef my_component(ctx):\n    return \"Context only function component.\"\n\nasync def render() -&gt; str:\n   return await Renderer().render(\n       my_component()\n   )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>_ContextOnlySyncFunctionComponent | _ContextOnlyAsyncFunctionComponent</code> <p>The decorated function.</p> required <p>Returns:</p> Type Description <code>_DecoratedContextOnlySyncFunctionComponent | _DecoratedContextOnlyAsyncFunctionComponent</code> <p>The created component.</p> Source code in <code>htmy/function_component.py</code> <pre><code>def context_only(\n    self,\n    func: _ContextOnlySyncFunctionComponent | _ContextOnlyAsyncFunctionComponent,\n) -&gt; _DecoratedContextOnlySyncFunctionComponent | _DecoratedContextOnlyAsyncFunctionComponent:\n    \"\"\"\n    Decorator that converts the decorated function into a component.\n\n    If used on an async function, the resulting component will also be async;\n    otherwise it will be sync.\n\n    Example:\n\n    ```python\n    @component.context_only\n    def my_component(ctx):\n        return \"Context only function component.\"\n\n    async def render() -&gt; str:\n       return await Renderer().render(\n           my_component()\n       )\n    ```\n\n    Arguments:\n        func: The decorated function.\n\n    Returns:\n        The created component.\n    \"\"\"\n\n    def wrapper() -&gt; SyncComponent | AsyncComponent:\n        func.htmy = func  # type: ignore[union-attr]\n        return func  # type: ignore[return-value]\n\n    # This assignment adds support for context-only function components without call signature.\n    wrapper.htmy = func  # type: ignore[attr-defined]\n    return wrapper  # type: ignore[return-value]\n</code></pre>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators.context_only_method","title":"<code>context_only_method(func)</code>","text":"<pre><code>context_only_method(func: _SyncFunctionComponent[TSelf]) -&gt; Callable[[TSelf], SyncComponent]\n</code></pre><pre><code>context_only_method(func: _AsyncFunctionComponent[TSelf]) -&gt; Callable[[TSelf], AsyncComponent]\n</code></pre> <p>Decorator that converts the decorated method into one that must be called without any arguments and returns a component instance.</p> <p>If used on an async method, the resulting component will also be async; otherwise it will be sync.</p> <p>Example:</p> <pre><code>@dataclass\nclass MyBusinessObject:\n    message: str\n\n    @component.context_only_method\n    def paragraph(self, context: Context) -&gt; Component:\n        return html.p(f\"{self.message} Goodbye!\")\n\n\nasync def render() -&gt; str:\n    return await Renderer().render(\n        MyBusinessObject(\"Hello!\").paragraph()\n    )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>_SyncFunctionComponent[U] | _AsyncFunctionComponent[U]</code> <p>The decorated method.</p> required <p>Returns:</p> Type Description <code>Callable[[U], SyncComponent] | Callable[[U], AsyncComponent]</code> <p>A method that must be called without any arguments and returns a component instance.</p> <code>Callable[[U], SyncComponent] | Callable[[U], AsyncComponent]</code> <p>(Or loosly speaking, an <code>HTMYComponentType</code> which can be \"instantiated\" by calling</p> <code>Callable[[U], SyncComponent] | Callable[[U], AsyncComponent]</code> <p>the method.)</p> Source code in <code>htmy/function_component.py</code> <pre><code>def context_only_method(\n    self,\n    func: _SyncFunctionComponent[TSelf] | _AsyncFunctionComponent[TSelf],\n) -&gt; Callable[[TSelf], SyncComponent] | Callable[[TSelf], AsyncComponent]:\n    \"\"\"\n    Decorator that converts the decorated method into one that must be called\n    without any arguments and returns a component instance.\n\n    If used on an async method, the resulting component will also be async;\n    otherwise it will be sync.\n\n    Example:\n\n    ```python\n    @dataclass\n    class MyBusinessObject:\n        message: str\n\n        @component.context_only_method\n        def paragraph(self, context: Context) -&gt; Component:\n            return html.p(f\"{self.message} Goodbye!\")\n\n\n    async def render() -&gt; str:\n        return await Renderer().render(\n            MyBusinessObject(\"Hello!\").paragraph()\n        )\n    ```\n\n    Arguments:\n        func: The decorated method.\n\n    Returns:\n        A method that must be called without any arguments and returns a component instance.\n        (Or loosly speaking, an `HTMYComponentType` which can be \"instantiated\" by calling\n        the method.)\n    \"\"\"\n    # A context only method component must be implemented in the same way as\n    # a function component. The self argument replaces the props argument\n    # and it is added automatically by Python when the method is called.\n    # Even the type hint must be the same.\n    # This implementation doesn't make the function itself a component though,\n    # so the call signature is always necessary (unlike for context-only function\n    # components).\n    return self(func)\n</code></pre>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators.function","title":"<code>function(func)</code>","text":"<pre><code>function(func: _SyncFunctionComponent[TProps]) -&gt; Callable[[TProps], SyncComponent]\n</code></pre><pre><code>function(func: _AsyncFunctionComponent[TProps]) -&gt; Callable[[TProps], AsyncComponent]\n</code></pre> <p>Decorator that converts the decorated function into one that must be called with the function component's properties and returns a component instance.</p> <p>If used on an async function, the resulting component will also be async; otherwise it will be sync.</p> <p>This function is just an alias for <code>__call__()</code>.</p> <p>Example:</p> <p>```python @component.function def my_component(props: int, context: Context) -&gt; Component:     return html.p(f\"Value: {props}\")</p> <p>async def render() -&gt; str:    return await Renderer().render(        my_component(42)    )</p> <p>Arguments:     func: The decorated function.</p> <p>Returns:     A function that must be called with the function component's properties and     returns a component instance. (Or loosly speaking, an <code>HTMYComponentType</code> which     can be \"instantiated\" with the function component's properties.)</p> Source code in <code>htmy/function_component.py</code> <pre><code>def function(\n    self,\n    func: _SyncFunctionComponent[TProps] | _AsyncFunctionComponent[TProps],\n) -&gt; Callable[[TProps], SyncComponent] | Callable[[TProps], AsyncComponent]:\n    \"\"\"\n    Decorator that converts the decorated function into one that must be called with\n    the function component's properties and returns a component instance.\n\n    If used on an async function, the resulting component will also be async;\n    otherwise it will be sync.\n\n    This function is just an alias for `__call__()`.\n\n    Example:\n\n    ```python\n    @component.function\n    def my_component(props: int, context: Context) -&gt; Component:\n        return html.p(f\"Value: {props}\")\n\n    async def render() -&gt; str:\n       return await Renderer().render(\n           my_component(42)\n       )\n\n    Arguments:\n        func: The decorated function.\n\n    Returns:\n        A function that must be called with the function component's properties and\n        returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n        can be \"instantiated\" with the function component's properties.)\n    \"\"\"\n    return self(func)\n</code></pre>"},{"location":"api/function_component/#htmy.function_component.ComponentDecorators.method","title":"<code>method(func)</code>","text":"<pre><code>method(func: _SyncMethodComponent[TSelf, TProps]) -&gt; Callable[[TSelf, TProps], SyncComponent]\n</code></pre><pre><code>method(func: _AsyncMethodComponent[TSelf, TProps]) -&gt; Callable[[TSelf, TProps], AsyncComponent]\n</code></pre> <p>Decorator that converts the decorated method into one that must be called with the method component's properties and returns a component instance.</p> <p>If used on an async method, the resulting component will also be async; otherwise it will be sync.</p> <p>Example:</p> <pre><code>@dataclass\nclass MyBusinessObject:\n    message: str\n\n    @component.method\n    def paragraph(self, props: int, context: Context) -&gt; Component:\n        return html.p(f\"{self.message} {props}\")\n\n\nasync def render() -&gt; str:\n    return await Renderer().render(\n        MyBusinessObject(\"Hi!\").paragraph(42)\n    )\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>_SyncMethodComponent[U, T] | _AsyncMethodComponent[U, T]</code> <p>The decorated method.</p> required <p>Returns:</p> Type Description <code>Callable[[U, T], SyncComponent] | Callable[[U, T], AsyncComponent]</code> <p>A method that must be called with the method component's properties and</p> <code>Callable[[U, T], SyncComponent] | Callable[[U, T], AsyncComponent]</code> <p>returns a component instance. (Or loosly speaking, an <code>HTMYComponentType</code> which</p> <code>Callable[[U, T], SyncComponent] | Callable[[U, T], AsyncComponent]</code> <p>can be \"instantiated\" with the method component's properties.)</p> Source code in <code>htmy/function_component.py</code> <pre><code>def method(\n    self,\n    func: _SyncMethodComponent[TSelf, TProps] | _AsyncMethodComponent[TSelf, TProps],\n) -&gt; Callable[[TSelf, TProps], SyncComponent] | Callable[[TSelf, TProps], AsyncComponent]:\n    \"\"\"\n    Decorator that converts the decorated method into one that must be called with\n    the method component's properties and returns a component instance.\n\n    If used on an async method, the resulting component will also be async;\n    otherwise it will be sync.\n\n    Example:\n\n    ```python\n    @dataclass\n    class MyBusinessObject:\n        message: str\n\n        @component.method\n        def paragraph(self, props: int, context: Context) -&gt; Component:\n            return html.p(f\"{self.message} {props}\")\n\n\n    async def render() -&gt; str:\n        return await Renderer().render(\n            MyBusinessObject(\"Hi!\").paragraph(42)\n        )\n    ```\n\n    Arguments:\n        func: The decorated method.\n\n    Returns:\n        A method that must be called with the method component's properties and\n        returns a component instance. (Or loosly speaking, an `HTMYComponentType` which\n        can be \"instantiated\" with the method component's properties.)\n    \"\"\"\n    if asyncio.iscoroutinefunction(func):\n\n        def async_wrapper(self: TSelf, props: TProps) -&gt; AsyncComponent:\n            # This function must be async, in case the renderer inspects it to decide how to handle it.\n            async def component(context: Context) -&gt; Component:\n                return await func(self, props, context)  # type: ignore[no-any-return]\n\n            component.htmy = component  # type: ignore[attr-defined]\n            return component  # type: ignore[return-value]\n\n        return async_wrapper\n    else:\n\n        def sync_wrapper(self: TSelf, props: TProps) -&gt; SyncComponent:\n            def component(context: Context) -&gt; Component:\n                return func(self, props, context)  # type: ignore[return-value]\n\n            component.htmy = component  # type: ignore[attr-defined]\n            return component  # type: ignore[return-value]\n\n        return sync_wrapper\n</code></pre>"},{"location":"api/html/","title":"HTML","text":""},{"location":"api/html/#htmy.html","title":"<code>htmy.html</code>","text":""},{"location":"api/html/#htmy.html.DOCTYPE","title":"<code>DOCTYPE</code>","text":"<p>Document type declaration.</p> Source code in <code>htmy/html.py</code> <pre><code>class DOCTYPE:\n    \"\"\"Document type declaration.\"\"\"\n\n    html = SafeStr(\"&lt;!DOCTYPE html&gt;\")\n    \"\"\"HTML document type.\"\"\"\n</code></pre>"},{"location":"api/html/#htmy.html.DOCTYPE.html","title":"<code>html = SafeStr('&lt;!DOCTYPE html&gt;')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>HTML document type.</p>"},{"location":"api/html/#htmy.html.a","title":"<code>a</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;a&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a.</p> Source code in <code>htmy/html.py</code> <pre><code>class a(Tag):\n    \"\"\"\n    `&lt;a&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.abbr","title":"<code>abbr</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;abbr&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr.</p> Source code in <code>htmy/html.py</code> <pre><code>class abbr(Tag):\n    \"\"\"\n    `&lt;abbr&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.address","title":"<code>address</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;address&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address.</p> Source code in <code>htmy/html.py</code> <pre><code>class address(Tag):\n    \"\"\"\n    `&lt;address&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.area","title":"<code>area</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;area&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area.</p> Source code in <code>htmy/html.py</code> <pre><code>class area(TagWithProps):\n    \"\"\"\n    `&lt;area&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.article","title":"<code>article</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;article&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article.</p> Source code in <code>htmy/html.py</code> <pre><code>class article(Tag):\n    \"\"\"\n    `&lt;article&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.aside","title":"<code>aside</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;aside&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside.</p> Source code in <code>htmy/html.py</code> <pre><code>class aside(Tag):\n    \"\"\"\n    `&lt;aside&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.audio","title":"<code>audio</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;audio&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio.</p> Source code in <code>htmy/html.py</code> <pre><code>class audio(Tag):\n    \"\"\"\n    `&lt;audio&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.b","title":"<code>b</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;b&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b.</p> Source code in <code>htmy/html.py</code> <pre><code>class b(Tag):\n    \"\"\"\n    `&lt;b&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.base","title":"<code>base</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;base&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base.</p> Source code in <code>htmy/html.py</code> <pre><code>class base(TagWithProps):\n    \"\"\"\n    `&lt;base&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.bdi","title":"<code>bdi</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;bdi&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi.</p> Source code in <code>htmy/html.py</code> <pre><code>class bdi(Tag):\n    \"\"\"\n    `&lt;bdi&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.bdo","title":"<code>bdo</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;bdo&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo.</p> Source code in <code>htmy/html.py</code> <pre><code>class bdo(Tag):\n    \"\"\"\n    `&lt;bdo&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.blockquote","title":"<code>blockquote</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;blockquote&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote.</p> Source code in <code>htmy/html.py</code> <pre><code>class blockquote(Tag):\n    \"\"\"\n    `&lt;blockquote&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.body","title":"<code>body</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;body&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body.</p> Source code in <code>htmy/html.py</code> <pre><code>class body(Tag):\n    \"\"\"\n    `&lt;body&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.br","title":"<code>br</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;br&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br.</p> Source code in <code>htmy/html.py</code> <pre><code>class br(TagWithProps):\n    \"\"\"\n    `&lt;br&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.button","title":"<code>button</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;button&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button.</p> Source code in <code>htmy/html.py</code> <pre><code>class button(Tag):\n    \"\"\"\n    `&lt;button&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.canvas","title":"<code>canvas</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;canvas&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas.</p> Source code in <code>htmy/html.py</code> <pre><code>class canvas(Tag):\n    \"\"\"\n    `&lt;canvas&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.caption","title":"<code>caption</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;caption&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption.</p> Source code in <code>htmy/html.py</code> <pre><code>class caption(Tag):\n    \"\"\"\n    `&lt;caption&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.cite","title":"<code>cite</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;cite&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite.</p> Source code in <code>htmy/html.py</code> <pre><code>class cite(Tag):\n    \"\"\"\n    `&lt;cite&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.code","title":"<code>code</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;code&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code.</p> Source code in <code>htmy/html.py</code> <pre><code>class code(Tag):\n    \"\"\"\n    `&lt;code&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.col","title":"<code>col</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;col&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col.</p> Source code in <code>htmy/html.py</code> <pre><code>class col(TagWithProps):\n    \"\"\"\n    `&lt;col&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.colgroup","title":"<code>colgroup</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;colgroup&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup.</p> Source code in <code>htmy/html.py</code> <pre><code>class colgroup(TagWithProps):\n    \"\"\"\n    `&lt;colgroup&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.data","title":"<code>data</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;data&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data.</p> Source code in <code>htmy/html.py</code> <pre><code>class data(Tag):\n    \"\"\"\n    `&lt;data&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.datalist","title":"<code>datalist</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;datalist&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist.</p> Source code in <code>htmy/html.py</code> <pre><code>class datalist(Tag):\n    \"\"\"\n    `&lt;datalist&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.dd","title":"<code>dd</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;dd&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd.</p> Source code in <code>htmy/html.py</code> <pre><code>class dd(Tag):\n    \"\"\"\n    `&lt;dd&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.del_","title":"<code>del_</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;del&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del.</p> Source code in <code>htmy/html.py</code> <pre><code>class del_(Tag):\n    \"\"\"\n    `&lt;del&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n\n    def _get_htmy_name(self) -&gt; str:\n        return \"del\"\n</code></pre>"},{"location":"api/html/#htmy.html.details","title":"<code>details</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;details&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details.</p> Source code in <code>htmy/html.py</code> <pre><code>class details(Tag):\n    \"\"\"\n    `&lt;details&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.dfn","title":"<code>dfn</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;dfn&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn.</p> Source code in <code>htmy/html.py</code> <pre><code>class dfn(Tag):\n    \"\"\"\n    `&lt;dfn&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.dialog","title":"<code>dialog</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;dialog&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog.</p> Source code in <code>htmy/html.py</code> <pre><code>class dialog(Tag):\n    \"\"\"\n    `&lt;dialog&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.div","title":"<code>div</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;div&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div.</p> Source code in <code>htmy/html.py</code> <pre><code>class div(Tag):\n    \"\"\"\n    `&lt;div&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.dl","title":"<code>dl</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;dl&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl.</p> Source code in <code>htmy/html.py</code> <pre><code>class dl(Tag):\n    \"\"\"\n    `&lt;dl&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.dt","title":"<code>dt</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;dt&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt.</p> Source code in <code>htmy/html.py</code> <pre><code>class dt(Tag):\n    \"\"\"\n    `&lt;dt&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.em","title":"<code>em</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;em&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em.</p> Source code in <code>htmy/html.py</code> <pre><code>class em(Tag):\n    \"\"\"\n    `&lt;em&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.embed","title":"<code>embed</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;embed&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed.</p> Source code in <code>htmy/html.py</code> <pre><code>class embed(TagWithProps):\n    \"\"\"\n    `&lt;embed&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.fieldset","title":"<code>fieldset</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;fieldset&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset.</p> Source code in <code>htmy/html.py</code> <pre><code>class fieldset(Tag):\n    \"\"\"\n    `&lt;fieldset&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.figcaption","title":"<code>figcaption</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;figcaption&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption.</p> Source code in <code>htmy/html.py</code> <pre><code>class figcaption(Tag):\n    \"\"\"\n    `&lt;figcaption&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.figure","title":"<code>figure</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;figure&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure.</p> Source code in <code>htmy/html.py</code> <pre><code>class figure(Tag):\n    \"\"\"\n    `&lt;figure&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.footer","title":"<code>footer</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;footer&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer.</p> Source code in <code>htmy/html.py</code> <pre><code>class footer(Tag):\n    \"\"\"\n    `&lt;footer&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.form","title":"<code>form</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;form&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form.</p> Source code in <code>htmy/html.py</code> <pre><code>class form(Tag):\n    \"\"\"\n    `&lt;form&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.h1","title":"<code>h1</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h1&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1.</p> Source code in <code>htmy/html.py</code> <pre><code>class h1(Tag):\n    \"\"\"\n    `&lt;h1&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.h2","title":"<code>h2</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h2&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2.</p> Source code in <code>htmy/html.py</code> <pre><code>class h2(Tag):\n    \"\"\"\n    `&lt;h2&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.h3","title":"<code>h3</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h3&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3.</p> Source code in <code>htmy/html.py</code> <pre><code>class h3(Tag):\n    \"\"\"\n    `&lt;h3&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.h4","title":"<code>h4</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h4&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4.</p> Source code in <code>htmy/html.py</code> <pre><code>class h4(Tag):\n    \"\"\"\n    `&lt;h4&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.h5","title":"<code>h5</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h5&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5.</p> Source code in <code>htmy/html.py</code> <pre><code>class h5(Tag):\n    \"\"\"\n    `&lt;h5&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.h6","title":"<code>h6</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;h6&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6.</p> Source code in <code>htmy/html.py</code> <pre><code>class h6(Tag):\n    \"\"\"\n    `&lt;h6&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.head","title":"<code>head</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;head&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head.</p> Source code in <code>htmy/html.py</code> <pre><code>class head(Tag):\n    \"\"\"\n    `&lt;head&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.header","title":"<code>header</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;header&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header.</p> Source code in <code>htmy/html.py</code> <pre><code>class header(Tag):\n    \"\"\"\n    `&lt;header&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.hgroup","title":"<code>hgroup</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;hgroup&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup.</p> Source code in <code>htmy/html.py</code> <pre><code>class hgroup(Tag):\n    \"\"\"\n    `&lt;hgroup&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.hr","title":"<code>hr</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;hr&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr.</p> Source code in <code>htmy/html.py</code> <pre><code>class hr(TagWithProps):\n    \"\"\"\n    `&lt;hr&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.html","title":"<code>html</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;html&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html.</p> Source code in <code>htmy/html.py</code> <pre><code>class html(Tag):\n    \"\"\"\n    `&lt;html&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.i","title":"<code>i</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;i&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i.</p> Source code in <code>htmy/html.py</code> <pre><code>class i(Tag):\n    \"\"\"\n    `&lt;i&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.iframe","title":"<code>iframe</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;iframe&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe.</p> Source code in <code>htmy/html.py</code> <pre><code>class iframe(Tag):\n    \"\"\"\n    `&lt;iframe&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.img","title":"<code>img</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;img&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img.</p> Source code in <code>htmy/html.py</code> <pre><code>class img(TagWithProps):\n    \"\"\"\n    `&lt;img&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.input_","title":"<code>input_</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;input&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input.</p> Source code in <code>htmy/html.py</code> <pre><code>class input_(TagWithProps):\n    \"\"\"\n    `&lt;input&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input.\n    \"\"\"\n\n    __slots__ = ()\n\n    def _get_htmy_name(self) -&gt; str:\n        return \"input\"\n</code></pre>"},{"location":"api/html/#htmy.html.ins","title":"<code>ins</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;ins&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins.</p> Source code in <code>htmy/html.py</code> <pre><code>class ins(Tag):\n    \"\"\"\n    `&lt;ins&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.kbd","title":"<code>kbd</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;kbd&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd.</p> Source code in <code>htmy/html.py</code> <pre><code>class kbd(Tag):\n    \"\"\"\n    `&lt;kbd&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.label","title":"<code>label</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;label&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label.</p> Source code in <code>htmy/html.py</code> <pre><code>class label(Tag):\n    \"\"\"\n    `&lt;label&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.legend","title":"<code>legend</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;legend&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend.</p> Source code in <code>htmy/html.py</code> <pre><code>class legend(Tag):\n    \"\"\"\n    `&lt;legend&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.li","title":"<code>li</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;li&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li.</p> Source code in <code>htmy/html.py</code> <pre><code>class li(Tag):\n    \"\"\"\n    `&lt;li&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.link","title":"<code>link</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;link&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link.</p> Source code in <code>htmy/html.py</code> <pre><code>class link(TagWithProps):\n    \"\"\"\n    `&lt;link&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link.\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def css(cls, href: str) -&gt; link:\n        return cls(rel=\"stylesheet\", type=\"text/css\", href=href)\n</code></pre>"},{"location":"api/html/#htmy.html.main","title":"<code>main</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;main&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main.</p> Source code in <code>htmy/html.py</code> <pre><code>class main(Tag):\n    \"\"\"\n    `&lt;main&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.map","title":"<code>map</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;map&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map.</p> Source code in <code>htmy/html.py</code> <pre><code>class map(Tag):\n    \"\"\"\n    `&lt;map&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.mark","title":"<code>mark</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;mark&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark.</p> Source code in <code>htmy/html.py</code> <pre><code>class mark(Tag):\n    \"\"\"\n    `&lt;mark&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.menu","title":"<code>menu</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;menu&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu.</p> Source code in <code>htmy/html.py</code> <pre><code>class menu(Tag):\n    \"\"\"\n    `&lt;menu&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.meta","title":"<code>meta</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;meta&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta.</p> Source code in <code>htmy/html.py</code> <pre><code>class meta(TagWithProps):\n    \"\"\"\n    `&lt;meta&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta.\n    \"\"\"\n\n    __slots__ = ()\n\n    @classmethod\n    def author(cls, content: str) -&gt; meta:\n        return cls(name=\"author\", content=content)\n\n    @classmethod\n    def charset(cls, charset: str = \"utf-8\") -&gt; meta:\n        return cls(charset=charset)\n\n    @classmethod\n    def description(cls, content: str) -&gt; meta:\n        return cls(name=\"description\", content=content)\n\n    @classmethod\n    def keywords(cls, content: str) -&gt; meta:\n        return cls(name=\"keywords\", content=content)\n\n    @classmethod\n    def viewport(cls, content: str = \"width=device-width, initial-scale=1.0\") -&gt; meta:\n        return cls(name=\"viewport\", content=content)\n</code></pre>"},{"location":"api/html/#htmy.html.meter","title":"<code>meter</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;meter&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter.</p> Source code in <code>htmy/html.py</code> <pre><code>class meter(Tag):\n    \"\"\"\n    `&lt;meter&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.nav","title":"<code>nav</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;nav&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav.</p> Source code in <code>htmy/html.py</code> <pre><code>class nav(Tag):\n    \"\"\"\n    `&lt;nav&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.noscript","title":"<code>noscript</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;noscript&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript.</p> Source code in <code>htmy/html.py</code> <pre><code>class noscript(Tag):\n    \"\"\"\n    `&lt;noscript&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.object","title":"<code>object</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;object&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object.</p> Source code in <code>htmy/html.py</code> <pre><code>class object(Tag):\n    \"\"\"\n    `&lt;object&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.ol","title":"<code>ol</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;ol&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol.</p> Source code in <code>htmy/html.py</code> <pre><code>class ol(Tag):\n    \"\"\"\n    `&lt;ol&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.optgroup","title":"<code>optgroup</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;optgroup&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup.</p> Source code in <code>htmy/html.py</code> <pre><code>class optgroup(Tag):\n    \"\"\"\n    `&lt;optgroup&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.option","title":"<code>option</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;option&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option.</p> Source code in <code>htmy/html.py</code> <pre><code>class option(Tag):\n    \"\"\"\n    `&lt;option&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.output","title":"<code>output</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;output&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output.</p> Source code in <code>htmy/html.py</code> <pre><code>class output(Tag):\n    \"\"\"\n    `&lt;output&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.p","title":"<code>p</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;p&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p.</p> Source code in <code>htmy/html.py</code> <pre><code>class p(Tag):\n    \"\"\"\n    `&lt;p&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.picture","title":"<code>picture</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;picture&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture.</p> Source code in <code>htmy/html.py</code> <pre><code>class picture(Tag):\n    \"\"\"\n    `&lt;picture&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.pre","title":"<code>pre</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;pre&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre.</p> Source code in <code>htmy/html.py</code> <pre><code>class pre(Tag):\n    \"\"\"\n    `&lt;pre&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.progress","title":"<code>progress</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;progress&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress.</p> Source code in <code>htmy/html.py</code> <pre><code>class progress(Tag):\n    \"\"\"\n    `&lt;progress&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.q","title":"<code>q</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;q&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q.</p> Source code in <code>htmy/html.py</code> <pre><code>class q(Tag):\n    \"\"\"\n    `&lt;q&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.s","title":"<code>s</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;s&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s.</p> Source code in <code>htmy/html.py</code> <pre><code>class s(Tag):\n    \"\"\"\n    `&lt;s&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.samp","title":"<code>samp</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;samp&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp.</p> Source code in <code>htmy/html.py</code> <pre><code>class samp(Tag):\n    \"\"\"\n    `&lt;samp&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.script","title":"<code>script</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;script&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script.</p> Source code in <code>htmy/html.py</code> <pre><code>class script(Tag):\n    \"\"\"\n    `&lt;script&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, text: str = \"\", **props: PropertyValue) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            text: The inner content of the tag. If not empty, it should be a\n                `SafeStr` for HTML and plain `str` for XHTML.\n            **props: Tag attributes.\n        \"\"\"\n        super().__init__(text, **props)\n</code></pre>"},{"location":"api/html/#htmy.html.script.__init__","title":"<code>__init__(text='', **props)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The inner content of the tag. If not empty, it should be a <code>SafeStr</code> for HTML and plain <code>str</code> for XHTML.</p> <code>''</code> <code>**props</code> <code>PropertyValue</code> <p>Tag attributes.</p> <code>{}</code> Source code in <code>htmy/html.py</code> <pre><code>def __init__(self, text: str = \"\", **props: PropertyValue) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        text: The inner content of the tag. If not empty, it should be a\n            `SafeStr` for HTML and plain `str` for XHTML.\n        **props: Tag attributes.\n    \"\"\"\n    super().__init__(text, **props)\n</code></pre>"},{"location":"api/html/#htmy.html.search","title":"<code>search</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;search&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/search.</p> Source code in <code>htmy/html.py</code> <pre><code>class search(Tag):\n    \"\"\"\n    `&lt;search&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/search.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.section","title":"<code>section</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;section&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section.</p> Source code in <code>htmy/html.py</code> <pre><code>class section(Tag):\n    \"\"\"\n    `&lt;section&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.select","title":"<code>select</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;select&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select.</p> Source code in <code>htmy/html.py</code> <pre><code>class select(Tag):\n    \"\"\"\n    `&lt;select&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.slot","title":"<code>slot</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;slot&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot.</p> Source code in <code>htmy/html.py</code> <pre><code>class slot(Tag):\n    \"\"\"\n    `&lt;slot&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.small","title":"<code>small</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;small&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small.</p> Source code in <code>htmy/html.py</code> <pre><code>class small(Tag):\n    \"\"\"\n    `&lt;small&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.source","title":"<code>source</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;source&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source.</p> Source code in <code>htmy/html.py</code> <pre><code>class source(TagWithProps):\n    \"\"\"\n    `&lt;source&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.span","title":"<code>span</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;span&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span.</p> Source code in <code>htmy/html.py</code> <pre><code>class span(Tag):\n    \"\"\"\n    `&lt;span&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.strong","title":"<code>strong</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;strong&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong.</p> Source code in <code>htmy/html.py</code> <pre><code>class strong(Tag):\n    \"\"\"\n    `&lt;strong&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.style","title":"<code>style</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;style&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style.</p> Source code in <code>htmy/html.py</code> <pre><code>class style(Tag):\n    \"\"\"\n    `&lt;style&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, content: str, **props: PropertyValue) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            content: The content of the tag. It is automatically converted to a `SafeStr`.\n            **props: Tag attributes.\n        \"\"\"\n        super().__init__(SafeStr(content), **props)\n</code></pre>"},{"location":"api/html/#htmy.html.style.__init__","title":"<code>__init__(content, **props)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content of the tag. It is automatically converted to a <code>SafeStr</code>.</p> required <code>**props</code> <code>PropertyValue</code> <p>Tag attributes.</p> <code>{}</code> Source code in <code>htmy/html.py</code> <pre><code>def __init__(self, content: str, **props: PropertyValue) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        content: The content of the tag. It is automatically converted to a `SafeStr`.\n        **props: Tag attributes.\n    \"\"\"\n    super().__init__(SafeStr(content), **props)\n</code></pre>"},{"location":"api/html/#htmy.html.sub","title":"<code>sub</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;sub&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub.</p> Source code in <code>htmy/html.py</code> <pre><code>class sub(Tag):\n    \"\"\"\n    `&lt;sub&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.summary","title":"<code>summary</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;summary&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary.</p> Source code in <code>htmy/html.py</code> <pre><code>class summary(Tag):\n    \"\"\"\n    `&lt;summary&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.sup","title":"<code>sup</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;sup&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup.</p> Source code in <code>htmy/html.py</code> <pre><code>class sup(Tag):\n    \"\"\"\n    `&lt;sup&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.svg","title":"<code>svg</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;svg&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg.</p> Source code in <code>htmy/html.py</code> <pre><code>class svg(Tag):\n    \"\"\"\n    `&lt;svg&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.table","title":"<code>table</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;table&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table.</p> Source code in <code>htmy/html.py</code> <pre><code>class table(Tag):\n    \"\"\"\n    `&lt;table&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.tbody","title":"<code>tbody</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;tbody&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody.</p> Source code in <code>htmy/html.py</code> <pre><code>class tbody(Tag):\n    \"\"\"\n    `&lt;tbody&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.td","title":"<code>td</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;td&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td.</p> Source code in <code>htmy/html.py</code> <pre><code>class td(Tag):\n    \"\"\"\n    `&lt;td&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.template","title":"<code>template</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template.</p> Source code in <code>htmy/html.py</code> <pre><code>class template(Tag):\n    \"\"\"\n    `&lt;&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.textarea","title":"<code>textarea</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;textarea&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea.</p> Source code in <code>htmy/html.py</code> <pre><code>class textarea(Tag):\n    \"\"\"\n    `&lt;textarea&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.tfoot","title":"<code>tfoot</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;tfoot&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot.</p> Source code in <code>htmy/html.py</code> <pre><code>class tfoot(Tag):\n    \"\"\"\n    `&lt;tfoot&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.th","title":"<code>th</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;th&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th.</p> Source code in <code>htmy/html.py</code> <pre><code>class th(Tag):\n    \"\"\"\n    `&lt;th&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.thead","title":"<code>thead</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;thead&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead.</p> Source code in <code>htmy/html.py</code> <pre><code>class thead(Tag):\n    \"\"\"\n    `&lt;thead&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.time","title":"<code>time</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;time&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time.</p> Source code in <code>htmy/html.py</code> <pre><code>class time(Tag):\n    \"\"\"\n    `&lt;time&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.title","title":"<code>title</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;title&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title.</p> Source code in <code>htmy/html.py</code> <pre><code>class title(Tag):\n    \"\"\"\n    `&lt;title&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n\n    def __init__(self, text: str, **props: PropertyValue) -&gt; None:\n        super().__init__(text, **props)\n</code></pre>"},{"location":"api/html/#htmy.html.tr","title":"<code>tr</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;tr&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr.</p> Source code in <code>htmy/html.py</code> <pre><code>class tr(Tag):\n    \"\"\"\n    `&lt;tr&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.track","title":"<code>track</code>","text":"<p>               Bases: <code>TagWithProps</code></p> <p><code>&lt;track&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track.</p> Source code in <code>htmy/html.py</code> <pre><code>class track(TagWithProps):\n    \"\"\"\n    `&lt;track&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.u","title":"<code>u</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;u&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u.</p> Source code in <code>htmy/html.py</code> <pre><code>class u(Tag):\n    \"\"\"\n    `&lt;u&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.ul","title":"<code>ul</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;ul&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul.</p> Source code in <code>htmy/html.py</code> <pre><code>class ul(Tag):\n    \"\"\"\n    `&lt;ul&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.var","title":"<code>var</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;var&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/var.</p> Source code in <code>htmy/html.py</code> <pre><code>class var(Tag):\n    \"\"\"\n    `&lt;var&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/var.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/html/#htmy.html.video","title":"<code>video</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;video&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video.</p> Source code in <code>htmy/html.py</code> <pre><code>class video(Tag):\n    \"\"\"\n    `&lt;video&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>"},{"location":"api/html/#htmy.html.wbr","title":"<code>wbr</code>","text":"<p>               Bases: <code>Tag</code></p> <p><code>&lt;&gt;</code> element.</p> <p>See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/.</p> Source code in <code>htmy/html.py</code> <pre><code>class wbr(Tag):\n    \"\"\"\n    `&lt;&gt;` element.\n\n    See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/.\n    \"\"\"\n\n    __slots__ = ()\n\n    tag_config = _DefaultTagConfig.inline_children\n</code></pre>"},{"location":"api/i18n/","title":"I18n","text":""},{"location":"api/i18n/#htmy.i18n","title":"<code>htmy.i18n</code>","text":""},{"location":"api/i18n/#htmy.i18n.TranslationResource","title":"<code>TranslationResource = Mapping[str, Any]</code>  <code>module-attribute</code>","text":"<p>Translation resource type.</p>"},{"location":"api/i18n/#htmy.i18n.I18n","title":"<code>I18n</code>","text":"<p>               Bases: <code>ContextAware</code></p> <p>Context-aware async internationalization utility.</p> Source code in <code>htmy/i18n.py</code> <pre><code>class I18n(ContextAware):\n    \"\"\"\n    Context-aware async internationalization utility.\n    \"\"\"\n\n    __slots__ = (\"_path\", \"_fallback\")\n\n    _root_keys: ClassVar[frozenset[str]] = frozenset((\"\", \".\"))\n    \"\"\"Special keys that represent the \"root\" object, i.e. the entire translation resource file.\"\"\"\n\n    def __init__(self, path: str | Path, fallback: str | Path | None = None) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            path: Path to the root directory that contains the translation resources.\n            fallback: Optional fallback path to use if `path` doesn't contain the required resources.\n        \"\"\"\n        self._path: Path = Path(path) if isinstance(path, str) else path\n        self._fallback: Path | None = Path(fallback) if isinstance(fallback, str) else fallback\n\n    @overload\n    async def get(self, dotted_path: str, key: str) -&gt; Any: ...\n\n    @overload\n    async def get(self, dotted_path: str, key: str, **kwargs: Any) -&gt; str: ...\n\n    async def get(self, dotted_path: str, key: str, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Returns the translation resource at the given location.\n\n        If keyword arguments are provided, it's expected that the referenced data\n        is a [format string](https://docs.python.org/3/library/string.html#formatstrings)\n        which can be fully formatted using the given keyword arguments.\n\n        Arguments:\n            dotted_path: A package-like (dot separated) path to the file that contains\n                the required translation resource, relative to `path`.\n            key: The key in the translation resource whose value is requested. Use dots to reference\n                embedded attributes.\n\n        Returns:\n            The loaded value.\n\n        Raises:\n            I18nError: If the given translation resource is not found or invalid.\n        \"\"\"\n        try:\n            return await self._resolve(self._path, dotted_path, key, **kwargs)\n        except I18nError:\n            if self._fallback is None:\n                raise\n\n            return await self._resolve(self._fallback, dotted_path, key, **kwargs)\n\n    @classmethod\n    async def _resolve(cls, root: Path, dotted_subpath: str, key: str, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Resolves the given translation resource.\n\n        Arguments:\n            root: The root path to use.\n            dotted_subpath: Subpath under `root` with dots as separators.\n            key: The key in the translation resource.\n\n        Returns:\n            The resolved translation resource.\n\n        Raises:\n            I18nKeyError: If the translation resource doesn't contain the requested key.\n            I18nValueError: If the translation resource is not found or its content is invalid.\n        \"\"\"\n        result = await load_translation_resource(resolve_json_path(root, dotted_subpath))\n        if key in cls._root_keys:\n            return result\n\n        for k in key.split(\".\"):\n            try:\n                result = result[k]\n            except KeyError as e:\n                raise I18nKeyError(f\"Key not found: {key}\") from e\n\n        if len(kwargs) &gt; 0:\n            if not isinstance(result, str):\n                raise I18nValueError(\"Formatting is only supported for strings.\")\n\n            return result.format(**kwargs)\n\n        return result\n</code></pre>"},{"location":"api/i18n/#htmy.i18n.I18n.__init__","title":"<code>__init__(path, fallback=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to the root directory that contains the translation resources.</p> required <code>fallback</code> <code>str | Path | None</code> <p>Optional fallback path to use if <code>path</code> doesn't contain the required resources.</p> <code>None</code> Source code in <code>htmy/i18n.py</code> <pre><code>def __init__(self, path: str | Path, fallback: str | Path | None = None) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        path: Path to the root directory that contains the translation resources.\n        fallback: Optional fallback path to use if `path` doesn't contain the required resources.\n    \"\"\"\n    self._path: Path = Path(path) if isinstance(path, str) else path\n    self._fallback: Path | None = Path(fallback) if isinstance(fallback, str) else fallback\n</code></pre>"},{"location":"api/i18n/#htmy.i18n.I18n.get","title":"<code>get(dotted_path, key, **kwargs)</code>  <code>async</code>","text":"<pre><code>get(dotted_path: str, key: str) -&gt; Any\n</code></pre><pre><code>get(dotted_path: str, key: str, **kwargs: Any) -&gt; str\n</code></pre> <p>Returns the translation resource at the given location.</p> <p>If keyword arguments are provided, it's expected that the referenced data is a format string which can be fully formatted using the given keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>dotted_path</code> <code>str</code> <p>A package-like (dot separated) path to the file that contains the required translation resource, relative to <code>path</code>.</p> required <code>key</code> <code>str</code> <p>The key in the translation resource whose value is requested. Use dots to reference embedded attributes.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The loaded value.</p> <p>Raises:</p> Type Description <code>I18nError</code> <p>If the given translation resource is not found or invalid.</p> Source code in <code>htmy/i18n.py</code> <pre><code>async def get(self, dotted_path: str, key: str, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Returns the translation resource at the given location.\n\n    If keyword arguments are provided, it's expected that the referenced data\n    is a [format string](https://docs.python.org/3/library/string.html#formatstrings)\n    which can be fully formatted using the given keyword arguments.\n\n    Arguments:\n        dotted_path: A package-like (dot separated) path to the file that contains\n            the required translation resource, relative to `path`.\n        key: The key in the translation resource whose value is requested. Use dots to reference\n            embedded attributes.\n\n    Returns:\n        The loaded value.\n\n    Raises:\n        I18nError: If the given translation resource is not found or invalid.\n    \"\"\"\n    try:\n        return await self._resolve(self._path, dotted_path, key, **kwargs)\n    except I18nError:\n        if self._fallback is None:\n            raise\n\n        return await self._resolve(self._fallback, dotted_path, key, **kwargs)\n</code></pre>"},{"location":"api/i18n/#htmy.i18n.load_translation_resource","title":"<code>load_translation_resource(path)</code>  <code>async</code>","text":"<p>Loads the translation resource from the given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path of the translation resource to load.</p> required <p>Returns:</p> Type Description <code>TranslationResource</code> <p>The loaded translation resource.</p> <p>Raises:</p> Type Description <code>I18nValueError</code> <p>If the translation resource is not a JSON dict.</p> Source code in <code>htmy/i18n.py</code> <pre><code>@alru_cache()\nasync def load_translation_resource(path: Path) -&gt; TranslationResource:\n    \"\"\"\n    Loads the translation resource from the given path.\n\n    Arguments:\n        path: The path of the translation resource to load.\n\n    Returns:\n        The loaded translation resource.\n\n    Raises:\n        I18nValueError: If the translation resource is not a JSON dict.\n    \"\"\"\n\n    try:\n        async with await open_file(path, \"r\") as f:\n            content = await f.read()\n    except FileNotFoundError as e:\n        raise I18nValueError(f\"Translation resource not found: {str(path)}\") from e\n\n    try:\n        result = json.loads(content)\n    except json.JSONDecodeError as e:\n        raise I18nValueError(\"Translation resource decoding failed.\") from e\n\n    if isinstance(result, dict):\n        return result\n\n    raise I18nValueError(\"Only dict translation resources are allowed.\")\n</code></pre>"},{"location":"api/i18n/#htmy.i18n.resolve_json_path","title":"<code>resolve_json_path(root, dotted_subpath)</code>","text":"<p>Resolves the given dotted subpath relative to root.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>The root path.</p> required <code>dotted_subpath</code> <code>str</code> <p>Subpath under <code>root</code> with dots as separators.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The resolved path.</p> <p>Raises:</p> Type Description <code>I18nValueError</code> <p>If the given dotted path is invalid.</p> Source code in <code>htmy/i18n.py</code> <pre><code>def resolve_json_path(root: Path, dotted_subpath: str) -&gt; Path:\n    \"\"\"\n    Resolves the given dotted subpath relative to root.\n\n    Arguments:\n        root: The root path.\n        dotted_subpath: Subpath under `root` with dots as separators.\n\n    Returns:\n        The resolved path.\n\n    Raises:\n        I18nValueError: If the given dotted path is invalid.\n    \"\"\"\n    *dirs, name = dotted_subpath.split(\".\")\n    if not name:\n        raise I18nValueError(\"Invalid path.\")\n\n    return root / Path(*dirs) / f\"{name}.json\"\n</code></pre>"},{"location":"api/md/","title":"Markdown","text":""},{"location":"api/md/#htmy.md.core","title":"<code>htmy.md.core</code>","text":""},{"location":"api/md/#htmy.md.core.MD","title":"<code>MD</code>","text":"<p>               Bases: <code>Snippet</code></p> <p>Component for reading, customizing, and rendering markdown documents.</p> <p>It supports all the processing utilities of <code>Snippet</code>, including <code>text_resolver</code> and <code>text_processor</code> for formatting, token replacement, and slot conversion to components.</p> <p>One note regarding slot conversion (<code>text_resolver</code>): it is executed before markdown parsing, and all string segments of the resulting component sequence are parsed individually by the markdown parser. As a consequence, you should only use slots in places where the preceding and following texts individually result in valid markdown.</p> <p>Warning: The component treats its input as trusted. If any part of the input comes from untrusted sources, ensure it is safely escaped (using for example <code>htmy.xml_format_string</code>)! Passing untrusted input to this component leads to XSS vulnerabilities.</p> Source code in <code>htmy/md/core.py</code> <pre><code>class MD(Snippet):\n    \"\"\"\n    Component for reading, customizing, and rendering markdown documents.\n\n    It supports all the processing utilities of `Snippet`, including `text_resolver` and\n    `text_processor` for formatting, token replacement, and slot conversion to components.\n\n    One note regarding slot conversion (`text_resolver`): it is executed before markdown parsing,\n    and all string segments of the resulting component sequence are parsed individually by the\n    markdown parser. As a consequence, you should only use slots in places where the preceding\n    and following texts individually result in valid markdown.\n\n    **Warning:** The component treats its input as trusted. If any part of the input comes from\n    untrusted sources, ensure it is safely escaped (using for example `htmy.xml_format_string`)!\n    Passing untrusted input to this component leads to XSS vulnerabilities.\n    \"\"\"\n\n    __slots__ = (\n        \"_converter\",\n        \"_renderer\",\n    )\n\n    def __init__(\n        self,\n        path_or_text: Text | str | Path,\n        text_resolver: TextResolver | None = None,\n        *,\n        converter: Callable[[str], Component] | None = None,\n        renderer: MarkdownRenderFunction | None = None,\n        text_processor: TextProcessor | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            path_or_text: The path where the markdown file is located or a markdown `Text`.\n            text_resolver: An optional `TextResolver` (e.g. `Slots`) that converts the processed\n                text into a component.\n            converter: Function that converts an HTML string (the parsed and processed markdown text)\n                into a component.\n            renderer: Function that gets the parsed and converted content and the metadata (if it exists)\n                and turns them into a component.\n            text_processor: An optional text processors that can be used to process the text\n                content before rendering. It can be used for example for token replacement or\n                string formatting.\n        \"\"\"\n        super().__init__(path_or_text, text_resolver, text_processor=text_processor)\n        self._converter: Callable[[str], Component] = SafeStr if converter is None else converter\n        self._renderer = renderer\n\n    def _render_text(self, text: str, context: Context) -&gt; Component:\n        md = MarkdownParser.from_context(context, MarkdownParser.default()).parse(text)\n        result = self._converter(md[\"content\"])\n        return result if self._renderer is None else self._renderer(result, md.get(\"metadata\", None))\n</code></pre>"},{"location":"api/md/#htmy.md.core.MD.__init__","title":"<code>__init__(path_or_text, text_resolver=None, *, converter=None, renderer=None, text_processor=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_text</code> <code>Text | str | Path</code> <p>The path where the markdown file is located or a markdown <code>Text</code>.</p> required <code>text_resolver</code> <code>TextResolver | None</code> <p>An optional <code>TextResolver</code> (e.g. <code>Slots</code>) that converts the processed text into a component.</p> <code>None</code> <code>converter</code> <code>Callable[[str], Component] | None</code> <p>Function that converts an HTML string (the parsed and processed markdown text) into a component.</p> <code>None</code> <code>renderer</code> <code>MarkdownRenderFunction | None</code> <p>Function that gets the parsed and converted content and the metadata (if it exists) and turns them into a component.</p> <code>None</code> <code>text_processor</code> <code>TextProcessor | None</code> <p>An optional text processors that can be used to process the text content before rendering. It can be used for example for token replacement or string formatting.</p> <code>None</code> Source code in <code>htmy/md/core.py</code> <pre><code>def __init__(\n    self,\n    path_or_text: Text | str | Path,\n    text_resolver: TextResolver | None = None,\n    *,\n    converter: Callable[[str], Component] | None = None,\n    renderer: MarkdownRenderFunction | None = None,\n    text_processor: TextProcessor | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        path_or_text: The path where the markdown file is located or a markdown `Text`.\n        text_resolver: An optional `TextResolver` (e.g. `Slots`) that converts the processed\n            text into a component.\n        converter: Function that converts an HTML string (the parsed and processed markdown text)\n            into a component.\n        renderer: Function that gets the parsed and converted content and the metadata (if it exists)\n            and turns them into a component.\n        text_processor: An optional text processors that can be used to process the text\n            content before rendering. It can be used for example for token replacement or\n            string formatting.\n    \"\"\"\n    super().__init__(path_or_text, text_resolver, text_processor=text_processor)\n    self._converter: Callable[[str], Component] = SafeStr if converter is None else converter\n    self._renderer = renderer\n</code></pre>"},{"location":"api/md/#htmy.md.core.MarkdownParser","title":"<code>MarkdownParser</code>","text":"<p>               Bases: <code>ContextAware</code></p> <p>Context-aware markdown parser.</p> <p>By default, this class uses the <code>markdown</code> library with a sensible set of extensions including code highlighting.</p> Source code in <code>htmy/md/core.py</code> <pre><code>class MarkdownParser(ContextAware):\n    \"\"\"\n    Context-aware markdown parser.\n\n    By default, this class uses the `markdown` library with a sensible set of\n    [extensions](https://python-markdown.github.io/extensions/) including code highlighting.\n    \"\"\"\n\n    __slots__ = (\"_md\",)\n\n    _default: ClassVar[MarkdownParser | None] = None\n    \"\"\"The default instance or `None` if one hasn't been created already.\"\"\"\n\n    @classmethod\n    def default(cls) -&gt; MarkdownParser:\n        \"\"\"\n        Returns the default instance.\n        \"\"\"\n        if cls._default is None:\n            cls._default = MarkdownParser()\n\n        return cls._default\n\n    def __init__(self, md: MarkdownParserFunction | None = None) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            md: The parser function to use.\n        \"\"\"\n        super().__init__()\n        self._md = md\n\n    def parse(self, text: str) -&gt; ParsedMarkdown:\n        \"\"\"\n        Returns the markdown data by parsing the given text.\n        \"\"\"\n        md = self._md\n        if md is None:\n            md = self._default_md()\n            self._md = md\n\n        return md(text)\n\n    def _default_md(self) -&gt; MarkdownParserFunction:\n        \"\"\"\n        Function that creates the default markdown parser.\n\n        Returns:\n            The default parser function.\n        \"\"\"\n        md = Markdown(extensions=(\"extra\", \"meta\", \"codehilite\"))\n\n        def parse(text: str) -&gt; ParsedMarkdown:\n            md.reset()\n            parsed = md.convert(text)\n            return {\"content\": parsed, \"metadata\": getattr(md, \"Meta\", None)}\n\n        return parse\n</code></pre>"},{"location":"api/md/#htmy.md.core.MarkdownParser.__init__","title":"<code>__init__(md=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>MarkdownParserFunction | None</code> <p>The parser function to use.</p> <code>None</code> Source code in <code>htmy/md/core.py</code> <pre><code>def __init__(self, md: MarkdownParserFunction | None = None) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        md: The parser function to use.\n    \"\"\"\n    super().__init__()\n    self._md = md\n</code></pre>"},{"location":"api/md/#htmy.md.core.MarkdownParser.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Returns the default instance.</p> Source code in <code>htmy/md/core.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; MarkdownParser:\n    \"\"\"\n    Returns the default instance.\n    \"\"\"\n    if cls._default is None:\n        cls._default = MarkdownParser()\n\n    return cls._default\n</code></pre>"},{"location":"api/md/#htmy.md.core.MarkdownParser.parse","title":"<code>parse(text)</code>","text":"<p>Returns the markdown data by parsing the given text.</p> Source code in <code>htmy/md/core.py</code> <pre><code>def parse(self, text: str) -&gt; ParsedMarkdown:\n    \"\"\"\n    Returns the markdown data by parsing the given text.\n    \"\"\"\n    md = self._md\n    if md is None:\n        md = self._default_md()\n        self._md = md\n\n    return md(text)\n</code></pre>"},{"location":"api/md/#htmy.md.typing","title":"<code>htmy.md.typing</code>","text":""},{"location":"api/md/#htmy.md.typing.MarkdownParserFunction","title":"<code>MarkdownParserFunction = Callable[[str], ParsedMarkdown]</code>  <code>module-attribute</code>","text":"<p>Callable that converts a markdown string into a <code>ParsedMarkdown</code> object.</p>"},{"location":"api/md/#htmy.md.typing.MarkdownRenderFunction","title":"<code>MarkdownRenderFunction = Callable[[Component, MarkdownMetadataDict | None], Component]</code>  <code>module-attribute</code>","text":"<p>Renderer function definition for markdown data.</p>"},{"location":"api/md/#htmy.md.typing.ParsedMarkdown","title":"<code>ParsedMarkdown</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type definition for parsed markdown data.</p> Source code in <code>htmy/md/typing.py</code> <pre><code>class ParsedMarkdown(TypedDict):\n    \"\"\"Type definition for parsed markdown data.\"\"\"\n\n    content: str\n    metadata: NotRequired[MarkdownMetadataDict | None]\n</code></pre>"},{"location":"api/snippet/","title":"Snippet","text":""},{"location":"api/snippet/#htmy.snippet","title":"<code>htmy.snippet</code>","text":""},{"location":"api/snippet/#htmy.snippet.Slots","title":"<code>Slots</code>","text":"<p>Utility that resolves slots in a string input to components.</p> <p>More technically, it splits a string into slot and non-slot parts, replaces the slot parts with the corresponding components (which may be component sequences) from the given slot mapping, and returns the resulting component sequence.</p> <p>The default slot placeholder is a standard XML/HTML comment of the following form: <code>&lt;!-- slot[slot-key] --&gt;</code>. Any number of whitespaces (including 0) are allowed in the placeholder, but the slot key must not contain any whitespaces. For details, see <code>Slots.slot_re</code>.</p> <p>Besides the pre-defined regular expressions in <code>Slots.slot_re</code>, any other regular expression can be used to identify slots as long as it meets the requirements described in <code>Slots.slots_re</code>.</p> <p>Implements: <code>htmy.typing.TextResolver</code></p> Source code in <code>htmy/snippet.py</code> <pre><code>class Slots:\n    \"\"\"\n    Utility that resolves slots in a string input to components.\n\n    More technically, it splits a string into slot and non-slot parts, replaces the\n    slot parts with the corresponding components (which may be component sequences)\n    from the given slot mapping, and returns the resulting component sequence.\n\n    The default slot placeholder is a standard XML/HTML comment of the following form:\n    `&lt;!-- slot[slot-key] --&gt;`. Any number of whitespaces (including 0) are allowed in\n    the placeholder, but the slot key must not contain any whitespaces. For details, see\n    `Slots.slot_re`.\n\n    Besides the pre-defined regular expressions in `Slots.slot_re`, any other regular\n    expression can be used to identify slots as long as it meets the requirements described\n    in `Slots.slots_re`.\n\n    Implements: `htmy.typing.TextResolver`\n    \"\"\"\n\n    __slots__ = (\"_slot_mapping\", \"_slot_re\", \"_not_found\")\n\n    class slot_re:\n        \"\"\"\n        Slot regular expressions.\n\n        Requirements:\n\n        - The regular expression must have exactly one capturing group that captures the slot key.\n        \"\"\"\n\n        square_bracket = re.compile(r\"&lt;!-- *slot *\\[ *([^[ ]+) *\\] *--&gt;\")\n        \"\"\"\n        Slot regular expression that matches slots defined as follows: `&lt;!-- slot[slot-key] --&gt;`.\n\n        The slot key must not contain any whitespaces and there must not be any additional text\n        in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the\n        parts of the slot placeholder.\n        \"\"\"\n        parentheses = re.compile(r\"&lt;!-- *slot *\\( *([^( ]+) *\\) *--&gt;\")\n        \"\"\"\n        Slot regular expression that matches slots defined as follows: `&lt;!-- slot(slot-key) --&gt;`.\n\n        The slot key must not contain any whitespaces and there must not be any additional text\n        in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the\n        parts of the slot placeholder.\n        \"\"\"\n\n        # There are no defaults for angle bracket and curly braces, because\n        # they may conflict with HTML and format strings.\n\n        default = square_bracket\n        \"\"\"\n        The default slot regular expression. Same as `Slots.slot_re.square_bracket`.\n        \"\"\"\n\n    def __init__(\n        self,\n        slot_mapping: Mapping[str, Component],\n        *,\n        slot_re: re.Pattern[str] = slot_re.default,\n        not_found: Component | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Slot regular expressions are used to find slot keys in strings, which are then replaced\n        with the corresponding component from the slot mapping. `slot_re` must have exactly one\n        capturing group that captures the slot key. `Slots.slot_re` contains some predefined slot\n        regular expressions, but any other regular expression can be used as long as it matches\n        the capturing group requirement above.\n\n        Arguments:\n            slot_mapping: Slot mapping the maps slot keys to the corresponding component.\n            slot_re: The slot regular expression that is used to find slot keys in strings.\n            not_found: The component that is used to replace slot keys that are not found in\n                `slot_mapping`. If `None` and the slot key is not found in `slot_mapping`,\n                then a `KeyError` will be raised by `resolve()`.\n        \"\"\"\n        self._slot_mapping = slot_mapping\n        self._slot_re = slot_re\n        self._not_found = not_found\n\n    def resolve_text(self, text: str) -&gt; Component:\n        \"\"\"\n        Resolves the given string into components using the instance's slot regular expression\n        and slot mapping.\n\n        Arguments:\n            text: The text to resolve.\n\n        Returns:\n           The component sequence the text resolves to.\n\n        Raises:\n            KeyError: If a slot key is not found in the slot mapping and `not_found` is `None`.\n        \"\"\"\n        return tuple(self._resolve_text(text))\n\n    def _resolve_text(self, text: str) -&gt; Iterator[ComponentType]:\n        \"\"\"\n        Generator that yields the slot and non-slot parts of the given string in order.\n\n        Arguments:\n            text: The text to resolve.\n\n        Yields:\n            The slot and non-slot parts of the given string.\n\n        Raises:\n            KeyError: If a slot key is not found in the slot mapping and `not_found` is `None`.\n        \"\"\"\n        is_slot = False\n        # The implementation requires that the slot regular expression has exactly one capturing group.\n        for part in self._slot_re.split(text):\n            if is_slot:\n                resolved = self._slot_mapping.get(part, self._not_found)\n                if resolved is None:\n                    raise KeyError(f\"Component not found for slot: {part}\")\n\n                if is_component_sequence(resolved):\n                    yield from resolved\n                else:\n                    # mypy complains that resolved may be a sequence, but that's not the case.\n                    yield resolved  # type: ignore[misc]\n            else:\n                yield part\n\n            is_slot = not is_slot\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Slots.slot_re","title":"<code>slot_re</code>","text":"<p>Slot regular expressions.</p> <p>Requirements:</p> <ul> <li>The regular expression must have exactly one capturing group that captures the slot key.</li> </ul> Source code in <code>htmy/snippet.py</code> <pre><code>class slot_re:\n    \"\"\"\n    Slot regular expressions.\n\n    Requirements:\n\n    - The regular expression must have exactly one capturing group that captures the slot key.\n    \"\"\"\n\n    square_bracket = re.compile(r\"&lt;!-- *slot *\\[ *([^[ ]+) *\\] *--&gt;\")\n    \"\"\"\n    Slot regular expression that matches slots defined as follows: `&lt;!-- slot[slot-key] --&gt;`.\n\n    The slot key must not contain any whitespaces and there must not be any additional text\n    in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the\n    parts of the slot placeholder.\n    \"\"\"\n    parentheses = re.compile(r\"&lt;!-- *slot *\\( *([^( ]+) *\\) *--&gt;\")\n    \"\"\"\n    Slot regular expression that matches slots defined as follows: `&lt;!-- slot(slot-key) --&gt;`.\n\n    The slot key must not contain any whitespaces and there must not be any additional text\n    in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the\n    parts of the slot placeholder.\n    \"\"\"\n\n    # There are no defaults for angle bracket and curly braces, because\n    # they may conflict with HTML and format strings.\n\n    default = square_bracket\n    \"\"\"\n    The default slot regular expression. Same as `Slots.slot_re.square_bracket`.\n    \"\"\"\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Slots.slot_re.default","title":"<code>default = square_bracket</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The default slot regular expression. Same as <code>Slots.slot_re.square_bracket</code>.</p>"},{"location":"api/snippet/#htmy.snippet.Slots.slot_re.parentheses","title":"<code>parentheses = re.compile('&lt;!-- *slot *\\\\( *([^( ]+) *\\\\) *--&gt;')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Slot regular expression that matches slots defined as follows: <code>&lt;!-- slot(slot-key) --&gt;</code>.</p> <p>The slot key must not contain any whitespaces and there must not be any additional text in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the parts of the slot placeholder.</p>"},{"location":"api/snippet/#htmy.snippet.Slots.slot_re.square_bracket","title":"<code>square_bracket = re.compile('&lt;!-- *slot *\\\\[ *([^[ ]+) *\\\\] *--&gt;')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Slot regular expression that matches slots defined as follows: <code>&lt;!-- slot[slot-key] --&gt;</code>.</p> <p>The slot key must not contain any whitespaces and there must not be any additional text in the XML/HTML comment. Any number of whitespaces (including 0) are allowed around the parts of the slot placeholder.</p>"},{"location":"api/snippet/#htmy.snippet.Slots.__init__","title":"<code>__init__(slot_mapping, *, slot_re=slot_re.default, not_found=None)</code>","text":"<p>Initialization.</p> <p>Slot regular expressions are used to find slot keys in strings, which are then replaced with the corresponding component from the slot mapping. <code>slot_re</code> must have exactly one capturing group that captures the slot key. <code>Slots.slot_re</code> contains some predefined slot regular expressions, but any other regular expression can be used as long as it matches the capturing group requirement above.</p> <p>Parameters:</p> Name Type Description Default <code>slot_mapping</code> <code>Mapping[str, Component]</code> <p>Slot mapping the maps slot keys to the corresponding component.</p> required <code>slot_re</code> <code>Pattern[str]</code> <p>The slot regular expression that is used to find slot keys in strings.</p> <code>default</code> <code>not_found</code> <code>Component | None</code> <p>The component that is used to replace slot keys that are not found in <code>slot_mapping</code>. If <code>None</code> and the slot key is not found in <code>slot_mapping</code>, then a <code>KeyError</code> will be raised by <code>resolve()</code>.</p> <code>None</code> Source code in <code>htmy/snippet.py</code> <pre><code>def __init__(\n    self,\n    slot_mapping: Mapping[str, Component],\n    *,\n    slot_re: re.Pattern[str] = slot_re.default,\n    not_found: Component | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Slot regular expressions are used to find slot keys in strings, which are then replaced\n    with the corresponding component from the slot mapping. `slot_re` must have exactly one\n    capturing group that captures the slot key. `Slots.slot_re` contains some predefined slot\n    regular expressions, but any other regular expression can be used as long as it matches\n    the capturing group requirement above.\n\n    Arguments:\n        slot_mapping: Slot mapping the maps slot keys to the corresponding component.\n        slot_re: The slot regular expression that is used to find slot keys in strings.\n        not_found: The component that is used to replace slot keys that are not found in\n            `slot_mapping`. If `None` and the slot key is not found in `slot_mapping`,\n            then a `KeyError` will be raised by `resolve()`.\n    \"\"\"\n    self._slot_mapping = slot_mapping\n    self._slot_re = slot_re\n    self._not_found = not_found\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Slots.resolve_text","title":"<code>resolve_text(text)</code>","text":"<p>Resolves the given string into components using the instance's slot regular expression and slot mapping.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to resolve.</p> required <p>Returns:</p> Type Description <code>Component</code> <p>The component sequence the text resolves to.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a slot key is not found in the slot mapping and <code>not_found</code> is <code>None</code>.</p> Source code in <code>htmy/snippet.py</code> <pre><code>def resolve_text(self, text: str) -&gt; Component:\n    \"\"\"\n    Resolves the given string into components using the instance's slot regular expression\n    and slot mapping.\n\n    Arguments:\n        text: The text to resolve.\n\n    Returns:\n       The component sequence the text resolves to.\n\n    Raises:\n        KeyError: If a slot key is not found in the slot mapping and `not_found` is `None`.\n    \"\"\"\n    return tuple(self._resolve_text(text))\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Snippet","title":"<code>Snippet</code>","text":"<p>Component that renders text, which may be asynchronously loaded from a file.</p> <p>Warning: The component treats its input as trusted. If any part of the input comes from untrusted sources, ensure it is safely escaped (using for example <code>htmy.xml_format_string</code>)! Passing untrusted input to this component leads to XSS vulnerabilities.</p> <p>The entire snippet processing pipeline consists of the following steps:</p> <ol> <li>The text content is loaded from a file or passed directly as a <code>Text</code> instance.</li> <li>The text content is processed by a <code>TextProcessor</code> if provided.</li> <li>The processed text is converted into a component (may be component sequence)    by a <code>TextResolver</code>, for example <code>Slots</code>.</li> <li>Every <code>str</code> children (produced by the steps above) is converted into a <code>SafeStr</code> for    rendering.</li> </ol> <p>The pipeline above is a bit abstract, so here are some usage notes:</p> <ul> <li>The text content of a snippet can be a Python format string template, in which case the   <code>TextProcessor</code> can be a simple method that calls <code>str.format()</code> with the correct arguments.</li> <li>Alternatively, a text processor can also be used to get only a substring -- commonly referred   to as fragment in frameworks like Jinja -- of the original text.</li> <li>The text processor is applied before the text resolver, which makes it possible to insert   placeholders into the text (for example slots, like in this case:   <code>...\"{toolbar}...\".format(toolbar=\"&lt;!-- slot[toolbar] --&gt;\")</code>) that are then replaced with any   <code>htmy.Component</code> by the <code>TextResolver</code> (for example <code>Slots</code>).</li> <li><code>TextResolver</code> can return plain <code>str</code> values, it is not necessary for it to convert strings   to <code>SafeStr</code> to prevent unwanted escaping.</li> </ul> <p>Example:</p> <pre><code>from datetime import date\nfrom htmy import Snippet, Slots\n\ndef text_processor(text: str, context: Context) -&gt; str:\n   return text.format(today=date.today())\n\nsnippet = Snippet(\n    \"my-page.html\",\n    text_processor=text_processor,\n    text_resolver=Slots(\n        {\n            \"date-picker\": MyDatePicker(class_=\"text-primary\"),\n            \"Toolbar\": MyPageToolbar(active_page=\"home\"),\n            ...\n        }\n    ),\n)\n</code></pre> <p>In the above example, if <code>my-page.html</code> contains a <code>{today}</code> placeholder, it will be replaced with the current date. If it contains a <code>&lt;!-- slot[toolbar] --&gt;}</code> slot, then the <code>MyPageToolbar</code> <code>htmy</code> component instance will be rendered in its place, and the <code>&lt;!-- slot[date-picker] --&gt;</code> slot will be replaced with the <code>MyDatePicker</code> component instance.</p> Source code in <code>htmy/snippet.py</code> <pre><code>class Snippet:\n    \"\"\"\n    Component that renders text, which may be asynchronously loaded from a file.\n\n    **Warning:** The component treats its input as trusted. If any part of the input comes from\n    untrusted sources, ensure it is safely escaped (using for example `htmy.xml_format_string`)!\n    Passing untrusted input to this component leads to XSS vulnerabilities.\n\n    The entire snippet processing pipeline consists of the following steps:\n\n    1. The text content is loaded from a file or passed directly as a `Text` instance.\n    2. The text content is processed by a `TextProcessor` if provided.\n    3. The processed text is converted into a component (may be component sequence)\n       by a `TextResolver`, for example `Slots`.\n    4. Every `str` children (produced by the steps above) is converted into a `SafeStr` for\n       rendering.\n\n    The pipeline above is a bit abstract, so here are some usage notes:\n\n    - The text content of a snippet can be a Python format string template, in which case the\n      `TextProcessor` can be a simple method that calls `str.format()` with the correct arguments.\n    - Alternatively, a text processor can also be used to get only a substring -- commonly referred\n      to as fragment in frameworks like Jinja -- of the original text.\n    - The text processor is applied before the text resolver, which makes it possible to insert\n      placeholders into the text (for example slots, like in this case:\n      `...\"{toolbar}...\".format(toolbar=\"&lt;!-- slot[toolbar] --&gt;\")`) that are then replaced with any\n      `htmy.Component` by the `TextResolver` (for example `Slots`).\n    - `TextResolver` can return plain `str` values, it is not necessary for it to convert strings\n      to `SafeStr` to prevent unwanted escaping.\n\n    Example:\n\n    ```python\n    from datetime import date\n    from htmy import Snippet, Slots\n\n    def text_processor(text: str, context: Context) -&gt; str:\n       return text.format(today=date.today())\n\n    snippet = Snippet(\n        \"my-page.html\",\n        text_processor=text_processor,\n        text_resolver=Slots(\n            {\n                \"date-picker\": MyDatePicker(class_=\"text-primary\"),\n                \"Toolbar\": MyPageToolbar(active_page=\"home\"),\n                ...\n            }\n        ),\n    )\n    ```\n\n    In the above example, if `my-page.html` contains a `{today}` placeholder, it will be replaced\n    with the current date. If it contains a `&lt;!-- slot[toolbar] --&gt;}` slot, then the `MyPageToolbar`\n    `htmy` component instance will be rendered in its place, and the `&lt;!-- slot[date-picker] --&gt;` slot\n    will be replaced with the `MyDatePicker` component instance.\n    \"\"\"\n\n    __slots__ = (\"_path_or_text\", \"_text_processor\", \"_text_resolver\")\n\n    def __init__(\n        self,\n        path_or_text: Text | str | Path,\n        text_resolver: TextResolver | None = None,\n        *,\n        text_processor: TextProcessor | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            path_or_text: The path from where the content should be loaded or a `Text`\n                instance if this value should be rendered directly.\n            text_resolver: An optional `TextResolver` (e.g. `Slots`) that converts the processed\n                text into a component. If not provided, the text will be rendered as a `SafeStr`.\n            text_processor: An optional `TextProcessor` that can be used to process the text\n                content before rendering. It can be used for example for token replacement or\n                string formatting.\n        \"\"\"\n        self._path_or_text = path_or_text\n        self._text_processor = text_processor\n        self._text_resolver = text_resolver\n\n    async def htmy(self, context: Context) -&gt; Component:\n        \"\"\"Renders the component.\"\"\"\n        text = await self._get_text_content()\n        if self._text_processor is not None:\n            processed = self._text_processor(text, context)\n            text = (await processed) if isinstance(processed, Awaitable) else processed\n\n        if self._text_resolver is None:\n            return self._render_text(text, context)\n\n        comps = as_component_sequence(self._text_resolver.resolve_text(text))\n        return tuple(\n            as_component_type(self._render_text(c, context)) if isinstance(c, str) else c for c in comps\n        )\n\n    async def _get_text_content(self) -&gt; str:\n        \"\"\"Returns the plain text content that should be rendered.\"\"\"\n        path_or_text = self._path_or_text\n\n        if isinstance(path_or_text, Text):\n            return path_or_text\n        else:\n            return await Snippet._load_text_file(path_or_text)\n\n    def _render_text(self, text: str, context: Context) -&gt; Component:\n        \"\"\"\n        Render function that takes the text that must be rendered and the current rendering context,\n        and returns the corresponding component.\n        \"\"\"\n        return SafeStr(text)\n\n    @staticmethod\n    @alru_cache()\n    async def _load_text_file(path: str | Path) -&gt; str:\n        \"\"\"Async text loader with an LRU cache.\"\"\"\n        return await load_text_file(path)\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Snippet.__init__","title":"<code>__init__(path_or_text, text_resolver=None, *, text_processor=None)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>path_or_text</code> <code>Text | str | Path</code> <p>The path from where the content should be loaded or a <code>Text</code> instance if this value should be rendered directly.</p> required <code>text_resolver</code> <code>TextResolver | None</code> <p>An optional <code>TextResolver</code> (e.g. <code>Slots</code>) that converts the processed text into a component. If not provided, the text will be rendered as a <code>SafeStr</code>.</p> <code>None</code> <code>text_processor</code> <code>TextProcessor | None</code> <p>An optional <code>TextProcessor</code> that can be used to process the text content before rendering. It can be used for example for token replacement or string formatting.</p> <code>None</code> Source code in <code>htmy/snippet.py</code> <pre><code>def __init__(\n    self,\n    path_or_text: Text | str | Path,\n    text_resolver: TextResolver | None = None,\n    *,\n    text_processor: TextProcessor | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        path_or_text: The path from where the content should be loaded or a `Text`\n            instance if this value should be rendered directly.\n        text_resolver: An optional `TextResolver` (e.g. `Slots`) that converts the processed\n            text into a component. If not provided, the text will be rendered as a `SafeStr`.\n        text_processor: An optional `TextProcessor` that can be used to process the text\n            content before rendering. It can be used for example for token replacement or\n            string formatting.\n    \"\"\"\n    self._path_or_text = path_or_text\n    self._text_processor = text_processor\n    self._text_resolver = text_resolver\n</code></pre>"},{"location":"api/snippet/#htmy.snippet.Snippet.htmy","title":"<code>htmy(context)</code>  <code>async</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/snippet.py</code> <pre><code>async def htmy(self, context: Context) -&gt; Component:\n    \"\"\"Renders the component.\"\"\"\n    text = await self._get_text_content()\n    if self._text_processor is not None:\n        processed = self._text_processor(text, context)\n        text = (await processed) if isinstance(processed, Awaitable) else processed\n\n    if self._text_resolver is None:\n        return self._render_text(text, context)\n\n    comps = as_component_sequence(self._text_resolver.resolve_text(text))\n    return tuple(\n        as_component_type(self._render_text(c, context)) if isinstance(c, str) else c for c in comps\n    )\n</code></pre>"},{"location":"api/typing/","title":"Typing","text":""},{"location":"api/typing/#htmy.typing","title":"<code>htmy.typing</code>","text":""},{"location":"api/typing/#htmy.typing.Component","title":"<code>Component = ComponentType | ComponentSequence</code>  <code>module-attribute</code>","text":"<p>Component type: a single component or a sequence of components.</p>"},{"location":"api/typing/#htmy.typing.ComponentSequence","title":"<code>ComponentSequence = list[ComponentType] | tuple[ComponentType, ...]</code>  <code>module-attribute</code>","text":"<p>Component sequence type.</p>"},{"location":"api/typing/#htmy.typing.ComponentType","title":"<code>ComponentType = HTMYComponentType | str</code>  <code>module-attribute</code>","text":"<p>Type definition for a single component.</p>"},{"location":"api/typing/#htmy.typing.Context","title":"<code>Context = Mapping[ContextKey, ContextValue]</code>  <code>module-attribute</code>","text":"<p>Context mapping.</p>"},{"location":"api/typing/#htmy.typing.ContextKey","title":"<code>ContextKey = Any</code>  <code>module-attribute</code>","text":"<p>Context key.</p>"},{"location":"api/typing/#htmy.typing.ContextProvider","title":"<code>ContextProvider = SyncContextProvider | AsyncContextProvider</code>  <code>module-attribute</code>","text":"<p>Sync or async context provider type.</p> <p>Components can implement this protocol to add extra data to the rendering context of their entire component subtree (including themselves).</p>"},{"location":"api/typing/#htmy.typing.ContextValue","title":"<code>ContextValue = Any</code>  <code>module-attribute</code>","text":"<p>Context value.</p>"},{"location":"api/typing/#htmy.typing.HTMYComponentType","title":"<code>HTMYComponentType = SyncComponent | AsyncComponent</code>  <code>module-attribute</code>","text":"<p>Sync or async <code>htmy</code> component type.</p>"},{"location":"api/typing/#htmy.typing.MutableContext","title":"<code>MutableContext = MutableMapping[ContextKey, ContextValue]</code>  <code>module-attribute</code>","text":"<p>Mutable context mapping.</p> <p>It can be helpful when the created context should be marked as mutable for static type analysis (usually the created context is a plain <code>dict</code>).</p>"},{"location":"api/typing/#htmy.typing.Properties","title":"<code>Properties = Mapping[str, PropertyValue]</code>  <code>module-attribute</code>","text":"<p>Component/XML tag property mapping.</p>"},{"location":"api/typing/#htmy.typing.PropertyValue","title":"<code>PropertyValue = Any | None</code>  <code>module-attribute</code>","text":"<p>Component/XML tag property value.</p>"},{"location":"api/typing/#htmy.typing.TextProcessor","title":"<code>TextProcessor = Callable[[str, Context], str | Coroutine[Any, Any, str]]</code>  <code>module-attribute</code>","text":"<p>Callable type that expects a string and a context, and returns a processed string.</p>"},{"location":"api/typing/#htmy.typing.AsyncComponent","title":"<code>AsyncComponent</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for async <code>htmy</code> components.</p> Source code in <code>htmy/typing.py</code> <pre><code>@runtime_checkable\nclass AsyncComponent(Protocol):\n    \"\"\"Protocol definition for async `htmy` components.\"\"\"\n\n    async def htmy(self, context: Context, /) -&gt; \"Component\":\n        \"\"\"Renders the component.\"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.AsyncComponent.htmy","title":"<code>htmy(context)</code>  <code>async</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/typing.py</code> <pre><code>async def htmy(self, context: Context, /) -&gt; \"Component\":\n    \"\"\"Renders the component.\"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.AsyncContextProvider","title":"<code>AsyncContextProvider</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for async context providers.</p> Source code in <code>htmy/typing.py</code> <pre><code>@runtime_checkable\nclass AsyncContextProvider(Protocol):\n    \"\"\"Protocol definition for async context providers.\"\"\"\n\n    async def htmy_context(self) -&gt; Context:\n        \"\"\"Returns a context for child rendering.\"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.AsyncContextProvider.htmy_context","title":"<code>htmy_context()</code>  <code>async</code>","text":"<p>Returns a context for child rendering.</p> Source code in <code>htmy/typing.py</code> <pre><code>async def htmy_context(self) -&gt; Context:\n    \"\"\"Returns a context for child rendering.\"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.RendererType","title":"<code>RendererType</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for <code>htmy</code> renderers.</p> Source code in <code>htmy/typing.py</code> <pre><code>class RendererType(Protocol):\n    \"\"\"Protocol definition for `htmy` renderers.\"\"\"\n\n    async def render(self, component: Component, context: Context | None = None) -&gt; str:\n        \"\"\"\n        Renders the given component.\n\n        Arguments:\n            component: The component to render.\n            context: An optional rendering context.\n\n        Returns:\n            The rendered string.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.RendererType.render","title":"<code>render(component, context=None)</code>  <code>async</code>","text":"<p>Renders the given component.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The component to render.</p> required <code>context</code> <code>Context | None</code> <p>An optional rendering context.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The rendered string.</p> Source code in <code>htmy/typing.py</code> <pre><code>async def render(self, component: Component, context: Context | None = None) -&gt; str:\n    \"\"\"\n    Renders the given component.\n\n    Arguments:\n        component: The component to render.\n        context: An optional rendering context.\n\n    Returns:\n        The rendered string.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.SyncComponent","title":"<code>SyncComponent</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for sync <code>htmy</code> components.</p> Source code in <code>htmy/typing.py</code> <pre><code>@runtime_checkable\nclass SyncComponent(Protocol):\n    \"\"\"Protocol definition for sync `htmy` components.\"\"\"\n\n    def htmy(self, context: Context, /) -&gt; \"Component\":\n        \"\"\"Renders the component.\"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.SyncComponent.htmy","title":"<code>htmy(context)</code>","text":"<p>Renders the component.</p> Source code in <code>htmy/typing.py</code> <pre><code>def htmy(self, context: Context, /) -&gt; \"Component\":\n    \"\"\"Renders the component.\"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.SyncContextProvider","title":"<code>SyncContextProvider</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for sync context providers.</p> Source code in <code>htmy/typing.py</code> <pre><code>@runtime_checkable\nclass SyncContextProvider(Protocol):\n    \"\"\"Protocol definition for sync context providers.\"\"\"\n\n    def htmy_context(self) -&gt; Context:\n        \"\"\"Returns a context for child rendering.\"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.SyncContextProvider.htmy_context","title":"<code>htmy_context()</code>","text":"<p>Returns a context for child rendering.</p> Source code in <code>htmy/typing.py</code> <pre><code>def htmy_context(self) -&gt; Context:\n    \"\"\"Returns a context for child rendering.\"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.TextResolver","title":"<code>TextResolver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for resolvers that convert a string to a component.</p> Source code in <code>htmy/typing.py</code> <pre><code>class TextResolver(Protocol):\n    \"\"\"\n    Protocol definition for resolvers that convert a string to a component.\n    \"\"\"\n\n    def resolve_text(self, text: str) -&gt; Component:\n        \"\"\"\n        Returns the resolved component for the given text.\n\n        Arguments:\n            text: The text to resolve.\n\n        Raises:\n            KeyError: If the text cannot be resolved to a component.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#htmy.typing.TextResolver.resolve_text","title":"<code>resolve_text(text)</code>","text":"<p>Returns the resolved component for the given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to resolve.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the text cannot be resolved to a component.</p> Source code in <code>htmy/typing.py</code> <pre><code>def resolve_text(self, text: str) -&gt; Component:\n    \"\"\"\n    Returns the resolved component for the given text.\n\n    Arguments:\n        text: The text to resolve.\n\n    Raises:\n        KeyError: If the text cannot be resolved to a component.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":""},{"location":"api/utils/#htmy.utils","title":"<code>htmy.utils</code>","text":""},{"location":"api/utils/#htmy.utils.as_component_sequence","title":"<code>as_component_sequence(comp)</code>","text":"<p>Returns the given component as a component sequence.</p> Source code in <code>htmy/utils.py</code> <pre><code>def as_component_sequence(comp: Component) -&gt; ComponentSequence:\n    \"\"\"Returns the given component as a component sequence.\"\"\"\n    # mypy doesn't understand the `is_component_sequence` type guard.\n    return comp if is_component_sequence(comp) else (comp,)  # type: ignore[return-value]\n</code></pre>"},{"location":"api/utils/#htmy.utils.as_component_type","title":"<code>as_component_type(comp)</code>","text":"<p>Returns the given component as a <code>ComponentType</code> (not sequence).</p> Source code in <code>htmy/utils.py</code> <pre><code>def as_component_type(comp: Component) -&gt; ComponentType:\n    \"\"\"Returns the given component as a `ComponentType` (not sequence).\"\"\"\n    from .core import Fragment\n\n    # mypy doesn't understand the `is_component_sequence` type guard.\n    return comp if not is_component_sequence(comp) else Fragment(*comp)  # type: ignore[return-value]\n</code></pre>"},{"location":"api/utils/#htmy.utils.is_component_sequence","title":"<code>is_component_sequence(comp)</code>","text":"<p>Returns whether the given component is a component sequence.</p> Source code in <code>htmy/utils.py</code> <pre><code>def is_component_sequence(comp: Component) -&gt; TypeGuard[ComponentSequence]:\n    \"\"\"Returns whether the given component is a component sequence.\"\"\"\n    return isinstance(comp, (list, tuple))\n</code></pre>"},{"location":"api/utils/#htmy.utils.join","title":"<code>join(*items, separator=' ')</code>","text":"<p>Joins the given strings with the given separator, skipping <code>None</code> values.</p> Source code in <code>htmy/utils.py</code> <pre><code>def join(*items: str | None, separator: str = \" \") -&gt; str:\n    \"\"\"\n    Joins the given strings with the given separator, skipping `None` values.\n    \"\"\"\n    return separator.join(i for i in items if i)\n</code></pre>"},{"location":"api/utils/#htmy.utils.join_components","title":"<code>join_components(components, separator, pad=False)</code>","text":"<p>Joins the given components using the given separator.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>ComponentSequence</code> <p>The components to join.</p> required <code>separator</code> <code>ComponentType</code> <p>The separator to use.</p> required <code>pad</code> <code>bool</code> <p>Whether to add a separator before the first and after the last components.</p> <code>False</code> Source code in <code>htmy/utils.py</code> <pre><code>def join_components(\n    components: ComponentSequence,\n    separator: ComponentType,\n    pad: bool = False,\n) -&gt; Generator[ComponentType, None, None]:\n    \"\"\"\n    Joins the given components using the given separator.\n\n    Arguments:\n        components: The components to join.\n        separator: The separator to use.\n        pad: Whether to add a separator before the first and after the last components.\n    \"\"\"\n    if len(components) == 0:\n        return\n\n    if pad:\n        yield separator\n\n    components_iterator = iter(components)\n    yield next(components_iterator)\n\n    for component in components_iterator:\n        yield separator\n        yield component\n\n    if pad:\n        yield separator\n</code></pre>"},{"location":"api/renderer/baseline/","title":"Baseline","text":""},{"location":"api/renderer/baseline/#htmy.renderer.baseline","title":"<code>htmy.renderer.baseline</code>","text":""},{"location":"api/renderer/baseline/#htmy.renderer.baseline.Renderer","title":"<code>Renderer</code>","text":"<p>The baseline component renderer.</p> <p>Because of the simple, recursive implementation, this renderer is the easiest to reason about. Therefore it is useful for validating component correctness before bug reporting (if another renderer implementation fails), testing and debugging alternative implementations, and it can also serve as the baseline for benchmarking optimized renderers.</p> <p>The performance of this renderer is not production quality.</p> Source code in <code>htmy/renderer/baseline.py</code> <pre><code>class Renderer:\n    \"\"\"\n    The baseline component renderer.\n\n    Because of the simple, recursive implementation, this renderer is the easiest to reason about.\n    Therefore it is useful for validating component correctness before bug reporting (if another\n    renderer implementation fails), testing and debugging alternative implementations, and it can\n    also serve as the baseline for benchmarking optimized renderers.\n\n    The performance of this renderer is not production quality.\n    \"\"\"\n\n    __slots__ = (\"_default_context\", \"_string_formatter\")\n\n    def __init__(\n        self,\n        default_context: Context | None = None,\n        *,\n        string_formatter: Callable[[str], str] = xml_format_string,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            default_context: The default context to use for rendering if `render()` doesn't\n                receive a context.\n            string_formatter: Callable that should be used to format plain strings. By default\n                an XML-safe string formatter will be used.\n        \"\"\"\n        self._default_context: Context = {} if default_context is None else default_context\n        self._string_formatter = string_formatter\n\n    async def render(self, component: Component, context: Context | None = None) -&gt; str:\n        \"\"\"\n        Renders the given component.\n\n        Implements `htmy.typing.RendererType`.\n\n        Arguments:\n            component: The component to render.\n            context: An optional rendering context.\n\n        Returns:\n            The rendered string.\n        \"\"\"\n        return await self._render(\n            component,\n            # Type ignore: ChainMap expects mutable mappings,\n            # but mutation is not supported by the Context typing.\n            self._default_context if context is None else ChainMap(context, self._default_context),  # type: ignore[arg-type]\n        )\n\n    async def _render(self, component: Component, context: Context) -&gt; str:\n        \"\"\"\n        Renders a single component \"level\".\n\n        Arguments:\n            component: The component to render.\n            context: The current rendering context.\n\n        Returns:\n            The rendered string.\n        \"\"\"\n        if isinstance(component, str):\n            return self._string_formatter(component)\n        elif isinstance(component, Iterable):\n            rendered_children = await asyncio.gather(\n                *(self._render_one(comp, context) for comp in component)\n            )\n\n            return \"\".join(rendered_children)\n        else:\n            return await self._render_one(component, context)\n\n    async def _render_one(self, component: ComponentType, context: Context) -&gt; str:\n        \"\"\"\n        Renders a single component.\n\n        Arguments:\n            component: The component to render.\n            context: The current rendering context.\n\n        Returns:\n            The rendered string.\n        \"\"\"\n        if isinstance(component, str):\n            return self._string_formatter(component)\n        else:\n            child_context: Context = context\n            if hasattr(component, \"htmy_context\"):  # isinstance() is too expensive.\n                extra_context: Context | Awaitable[Context] = component.htmy_context()\n                if isinstance(extra_context, Awaitable):\n                    extra_context = await extra_context\n\n                if len(extra_context):\n                    # Context must not be mutated, so we can ignore that ChainMap expext mutable mappings.\n                    child_context = ChainMap(extra_context, context)  # type: ignore[arg-type]\n\n            try:\n                children = component.htmy(child_context)\n                if isinstance(children, Awaitable):\n                    children = await children\n\n                return await self._render(children, child_context)\n            except Exception as e:\n                if isinstance(component, ErrorBoundary):\n                    return await self._render_one(component.fallback_component(e), context)\n\n                raise e\n</code></pre>"},{"location":"api/renderer/baseline/#htmy.renderer.baseline.Renderer.__init__","title":"<code>__init__(default_context=None, *, string_formatter=xml_format_string)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>default_context</code> <code>Context | None</code> <p>The default context to use for rendering if <code>render()</code> doesn't receive a context.</p> <code>None</code> <code>string_formatter</code> <code>Callable[[str], str]</code> <p>Callable that should be used to format plain strings. By default an XML-safe string formatter will be used.</p> <code>xml_format_string</code> Source code in <code>htmy/renderer/baseline.py</code> <pre><code>def __init__(\n    self,\n    default_context: Context | None = None,\n    *,\n    string_formatter: Callable[[str], str] = xml_format_string,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        default_context: The default context to use for rendering if `render()` doesn't\n            receive a context.\n        string_formatter: Callable that should be used to format plain strings. By default\n            an XML-safe string formatter will be used.\n    \"\"\"\n    self._default_context: Context = {} if default_context is None else default_context\n    self._string_formatter = string_formatter\n</code></pre>"},{"location":"api/renderer/baseline/#htmy.renderer.baseline.Renderer.render","title":"<code>render(component, context=None)</code>  <code>async</code>","text":"<p>Renders the given component.</p> <p>Implements <code>htmy.typing.RendererType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The component to render.</p> required <code>context</code> <code>Context | None</code> <p>An optional rendering context.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The rendered string.</p> Source code in <code>htmy/renderer/baseline.py</code> <pre><code>async def render(self, component: Component, context: Context | None = None) -&gt; str:\n    \"\"\"\n    Renders the given component.\n\n    Implements `htmy.typing.RendererType`.\n\n    Arguments:\n        component: The component to render.\n        context: An optional rendering context.\n\n    Returns:\n        The rendered string.\n    \"\"\"\n    return await self._render(\n        component,\n        # Type ignore: ChainMap expects mutable mappings,\n        # but mutation is not supported by the Context typing.\n        self._default_context if context is None else ChainMap(context, self._default_context),  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"api/renderer/default/","title":"Default","text":""},{"location":"api/renderer/default/#htmy.renderer.default","title":"<code>htmy.renderer.default</code>","text":""},{"location":"api/renderer/default/#htmy.renderer.default.Renderer","title":"<code>Renderer</code>","text":"<p>The default renderer.</p> <p>It resolves component trees by converting them to a linked list of resolved component parts before combining them to the final string.</p> Source code in <code>htmy/renderer/default.py</code> <pre><code>class Renderer:\n    \"\"\"\n    The default renderer.\n\n    It resolves component trees by converting them to a linked list of resolved component parts\n    before combining them to the final string.\n    \"\"\"\n\n    __slots__ = (\"_default_context\", \"_string_formatter\")\n\n    def __init__(\n        self,\n        default_context: Context | None = None,\n        *,\n        string_formatter: Callable[[str], str] = xml_format_string,\n    ) -&gt; None:\n        \"\"\"\n        Initialization.\n\n        Arguments:\n            default_context: The default context to use for rendering if `render()` doesn't\n                receive a context.\n            string_formatter: Callable that should be used to format plain strings. By default\n                an XML-safe string formatter will be used.\n        \"\"\"\n        self._default_context: Context = {} if default_context is None else default_context\n        self._string_formatter = string_formatter\n\n    async def render(self, component: Component, context: Context | None = None) -&gt; str:\n        \"\"\"\n        Renders the given component.\n\n        Implements `htmy.typing.RendererType`.\n\n        Arguments:\n            component: The component to render.\n            context: An optional rendering context.\n\n        Returns:\n            The rendered string.\n        \"\"\"\n        # Type ignore: ChainMap expects mutable mappings, but context mutation is not allowed so don't care.\n        context = (\n            self._default_context if context is None else ChainMap(context, self._default_context)  # type: ignore[arg-type]\n        )\n        return await _render_component(component, context=context, string_formatter=self._string_formatter)\n</code></pre>"},{"location":"api/renderer/default/#htmy.renderer.default.Renderer.__init__","title":"<code>__init__(default_context=None, *, string_formatter=xml_format_string)</code>","text":"<p>Initialization.</p> <p>Parameters:</p> Name Type Description Default <code>default_context</code> <code>Context | None</code> <p>The default context to use for rendering if <code>render()</code> doesn't receive a context.</p> <code>None</code> <code>string_formatter</code> <code>Callable[[str], str]</code> <p>Callable that should be used to format plain strings. By default an XML-safe string formatter will be used.</p> <code>xml_format_string</code> Source code in <code>htmy/renderer/default.py</code> <pre><code>def __init__(\n    self,\n    default_context: Context | None = None,\n    *,\n    string_formatter: Callable[[str], str] = xml_format_string,\n) -&gt; None:\n    \"\"\"\n    Initialization.\n\n    Arguments:\n        default_context: The default context to use for rendering if `render()` doesn't\n            receive a context.\n        string_formatter: Callable that should be used to format plain strings. By default\n            an XML-safe string formatter will be used.\n    \"\"\"\n    self._default_context: Context = {} if default_context is None else default_context\n    self._string_formatter = string_formatter\n</code></pre>"},{"location":"api/renderer/default/#htmy.renderer.default.Renderer.render","title":"<code>render(component, context=None)</code>  <code>async</code>","text":"<p>Renders the given component.</p> <p>Implements <code>htmy.typing.RendererType</code>.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The component to render.</p> required <code>context</code> <code>Context | None</code> <p>An optional rendering context.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The rendered string.</p> Source code in <code>htmy/renderer/default.py</code> <pre><code>async def render(self, component: Component, context: Context | None = None) -&gt; str:\n    \"\"\"\n    Renders the given component.\n\n    Implements `htmy.typing.RendererType`.\n\n    Arguments:\n        component: The component to render.\n        context: An optional rendering context.\n\n    Returns:\n        The rendered string.\n    \"\"\"\n    # Type ignore: ChainMap expects mutable mappings, but context mutation is not allowed so don't care.\n    context = (\n        self._default_context if context is None else ChainMap(context, self._default_context)  # type: ignore[arg-type]\n    )\n    return await _render_component(component, context=context, string_formatter=self._string_formatter)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Tutorials and examples for various features of the library.</p> <p>For complete, working examples, see the examples folder in the repo.</p> <p>External examples:</p> <ul> <li>lipsum-chat: A simple chat application using <code>FastAPI</code>, <code>htmx</code>, and <code>fasthx</code>.</li> </ul>"},{"location":"examples/fastapi-htmx-tailwind-daisyui/","title":"FastAPI with HTMX, TailwindCSS, and DaisyUI","text":"<p>First you must install all the necessary libraries (<code>FastAPI</code>, <code>uvicorn</code>, and <code>htmy</code>), for example like this:</p> <pre><code>$ pip install fastapi uvicorn htmy\n</code></pre> <p>You should be able to follow how components work and how the context can be used even without being familiar with HTMX, TailwindCSS, and DaisyUI, just ignore the styling and the <code>hx_*</code> attributes. But if you plan to play with this example, minimal familiarity with these tools will be very helpful.</p> <p>Now you should create an <code>app.py</code> file with this content:</p> <pre><code>from collections.abc import Awaitable, Callable\nfrom dataclasses import dataclass\nfrom typing import Annotated\n\nfrom fastapi import Depends, FastAPI, Request\nfrom fastapi.responses import HTMLResponse\n\nfrom htmy import Component, ComponentType, Context, Renderer, component, html, is_component_sequence\n\n\n@dataclass\nclass User:\n    \"\"\"Some user data model for the application.\"\"\"\n\n    name: str\n    preferred_theme: str\n\n\ndef make_htmy_context(request: Request) -&gt; Context:\n    \"\"\"Creates the base htmy context for rendering.\"\"\"\n    # The context will map the `Request` type to the current request and the User class\n    # to the current user. This is similar to what the `ContextAware` utility does, but\n    # simpler. With this context, components will be able to easily access the request\n    # and the user if they need it.\n    return {Request: request, User: User(name=\"Paul\", preferred_theme=\"dark\")}\n\n\nRendererFunction = Callable[[Component], Awaitable[HTMLResponse]]\n\n\ndef render(request: Request) -&gt; RendererFunction:\n    \"\"\"FastAPI dependency that returns an htmy renderer function.\"\"\"\n\n    async def exec(component: Component) -&gt; HTMLResponse:\n        # Note that we add the result of `make_htmy_context()` as the default context to\n        # the renderer. This way wherever this function is used for rendering in routes,\n        # every rendered component will be able to access the current request and user.\n        renderer = Renderer(make_htmy_context(request))\n        return HTMLResponse(await renderer.render(component))\n\n    return exec\n\n\nDependsRenderFunc = Annotated[RendererFunction, Depends(render)]\n\n\n@component\ndef page(content: ComponentType, context: Context) -&gt; Component:\n    \"\"\"\n    Page component that wraps the given `content` in the `&lt;body&gt;` tag.\n\n    This is just the base page layout component with all the necessary metadata and some styling.\n    \"\"\"\n    # Take the user from the context, so we can set the page theme (through DaisyUI).\n    user: User = context[User]\n    return (\n        html.DOCTYPE.html,\n        html.html(\n            html.head(\n                # Some metadata\n                html.title(\"Demo\"),\n                html.meta.charset(),\n                html.meta.viewport(),\n                # TailwindCSS and DaisyUI\n                html.script(src=\"https://cdn.tailwindcss.com\"),\n                html.link.css(\"https://cdn.jsdelivr.net/npm/daisyui@4.12.11/dist/full.min.css\"),\n                # HTMX\n                html.script(src=\"https://unpkg.com/htmx.org@2.0.2\"),\n            ),\n            html.body(\n                content,\n                data_theme=user.preferred_theme,\n                class_=\"h-screen w-screen\",\n            ),\n            lang=\"en\",\n        ),\n    )\n\n\n@component\ndef center(content: Component, context: Context) -&gt; Component:\n    \"\"\"Component that shows its content in the center of the available space.\"\"\"\n    return html.div(\n        *(content if is_component_sequence(content) else [content]),\n        class_=\"flex flex-col w-full h-full items-center justify-center gap-4\",\n    )\n\n\n@component\ndef counter(value: int, context: Context) -&gt; Component:\n    \"\"\"\n    Counter button with HTMX functionality.\n\n    Whenever the button is clicked, a request will be sent to the server and the\n    button will be re-rendered with the new value of the counter.\n    \"\"\"\n    # Attribute names will automatically be converted to \"hx-*\" and \"class\".\n    return html.button(\n        f\"Click {value} times.\",\n        hx_trigger=\"click\",\n        hx_swap=\"outerHTML\",\n        hx_post=f\"/counter-click?value={value}\",\n        class_=\"btn btn-primary\",\n    )\n\n\n@component\ndef welcome_message(props: None, context: Context) -&gt; Component:\n    \"\"\"Welcome message component.\"\"\"\n    # Take the request and the user from the context for use in the component.\n    request: Request = context[Request]\n    user: User = context[User]\n    return center(\n        (\n            html.h1(f'Welcome {user.name} at \"{request.url.path}\"!'),\n            counter(0),\n        )\n    )\n\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def index(render: DependsRenderFunc) -&gt; HTMLResponse:\n    \"\"\"The index page of the application.\"\"\"\n    return await render(page(welcome_message(None)))\n\n\n@app.post(\"/counter-click\")\nasync def counter_click(value: int, render: DependsRenderFunc) -&gt; HTMLResponse:\n    \"\"\"HTMX route that handles counter button clicks by re-rendering the button with the new value.\"\"\"\n    return await render(counter(value + 1))\n</code></pre> <p>Finally, you can run the application like this:</p> <pre><code>$ uvicorn app:app --reload\n</code></pre> <p>You can now open the application at <code>localhost:8000</code>.</p>"},{"location":"examples/internationalization/","title":"Internationalization","text":"<p>The focus of this example is using the built-in <code>I18n</code> utility for internationalization. All you need to follow the example is <code>htmy</code>, which you can install with <code>pip install htmy</code>.</p> <p>First of all, we must create some translation resources (plain JSON files). Let's do this by creating the <code>locale/en/page</code> folder structure and adding a <code>hello.json</code> in the <code>page</code> folder with the following content: <code>{ \"message\": \"Hey {name}\" }</code>. Notice the Python format string in the value for the <code>\"message\"</code> key, such strings can be automatically formatted by <code>I18n</code>, see the details in the docs and in the usage example below.</p> <p>Using <code>I18n</code> consists of only two steps: create an <code>I18n</code> instance, and include it in the rendering context so it can be accessed by components in their <code>htmy()</code> (render) method.</p> <p>With the translation resource in place, we can create the <code>app.py</code> file and implement our translated components like this:</p> <pre><code>import asyncio\nfrom pathlib import Path\n\nfrom htmy import Component, Context, Renderer, html\nfrom htmy.i18n import I18n\n\n\nclass TranslatedComponent:\n    \"\"\"Component with translated content.\"\"\"\n\n    async def htmy(self, context: Context) -&gt; Component:\n        # Get the I18n instance from the rendering context.\n        i18n = I18n.from_context(context)\n        # Get the translated message.\n        # The translation file can referenced with a dotted path.\n        # The second argument is the requested key in the translation file.\n        # Keyword arguments can be used for automatic string formatting.\n        message = await i18n.get(\"page.hello\", \"message\", name=\"Joe\")\n        # And return component's content.\n        return html.p(message)\n</code></pre> <p>Now that we have a component to render, we can create our <code>I18n</code> instance and write the async function that renders our content:</p> <pre><code>base_folder = Path(__file__).parent\n\"\"\"The folder where the app and all its content live.\"\"\"\n\ni18n = I18n(base_folder / \"locale\" / \"en\")\n\"\"\"\nThe `I18n` instance that we can add to the rendering context.\n\nIt takes translations from the `locale/en` folder.\n\"\"\"\n\n\nasync def render_hello() -&gt; None:\n    rendered = await Renderer().render(\n        # Render a TranslatedComponent.\n        TranslatedComponent(),\n        # Include the created I18n instance in the rendering context.\n        i18n.to_context(),\n    )\n    print(rendered)\n</code></pre> <p>Finally we add the usual <code>asyncio</code> run call:</p> <pre><code>if __name__ == \"__main__\":\n    asyncio.run(render_hello())\n</code></pre> <p>With <code>app.py</code> and the <code>locale/en/page/hello.json</code> translation resource in place, we can finally run the application with <code>python app.py</code> and see the translated content in the result. That's it.</p>"},{"location":"examples/markdown/","title":"Markdown rendering","text":"<p>The focus of this example is markdown rendering and customization. As such, all you need to follow along is <code>htmy</code>, which you can install with <code>pip install htmy</code>.</p> <p>There's one important thing to know about markdown in relation to this tutorial and the markdown support in <code>htmy</code>: markdown can include HTML (well, XML). Looking at this from another perspective, most HTML/XML snippets can be parsed by markdown parsers without issues. This means that while the below examples work with text files with markdown syntax, those file could also contain plain HTML snippets with no \"markdown\" at all. You will start to see the full power of this concept by the end of this article.</p> <p>Warning: The <code>MD</code> component treats its input as trusted. If any part of the input comes from untrusted sources, ensure it is safely escaped (using for example <code>htmy.xml_format_string</code>)! Passing untrusted input to the <code>MD</code> component leads to XSS vulnerabilities.</p>"},{"location":"examples/markdown/#essentials","title":"Essentials","text":"<p>The entire example will consist of two files: <code>post.md</code> and <code>app.py</code> which should be located next to each other in the same directory.</p> <p>First we create a simple markdown file (<code>post.md</code>) which only contains standard markdown syntax, including headers, lists, code blocks:</p> <pre><code># Essential reading\n\n```python\nimport this\n```\n\nAlso available [here](https://peps.python.org/pep-0020/).\n\nInline `code` is **also** _fine_.\n\n# Lists\n\n## Ordered\n\n1. First\n2. Second\n3. Third\n\n## Unordered\n\n- First\n- Second\n- Third\n</code></pre> <p>Then we can create the most minimal version of <code>app.py</code> that will be responsible for rendering <code>post.md</code> as HTML. Keep in mind that <code>htmy</code> is an async rendering engine, so we will need <code>asyncio</code> (specifically <code>asyncio.run()</code>) to run the renderer.</p> <pre><code>import asyncio\n\nfrom htmy import Renderer, md\n\n\nasync def render_post() -&gt; None:\n    md_post = md.MD(\"post.md\")  # Create an htmy.md.MD component.\n    rendered = await Renderer().render(md_post)  # Render the MD component.\n    print(rendered)  # Print the result.\n\n\nif __name__ == \"__main__\":\n    asyncio.run(render_post())\n</code></pre> <p>That's it. You can now run <code>app.py</code> from the terminal with <code>python app.py</code>, and it will print out the generated HTML snippet. You can save the output to an HTML file, or even better, pipe the output of the script directly to a file with <code>python app.py &gt; post.html</code> and just open the resulting HTML file in your browser.</p>"},{"location":"examples/markdown/#customization","title":"Customization","text":"<p>In this section we will extend the above example by adding custom rendering rules that apply extra CSS classes to a couple of standard HTML elements. The extra styling will be done by TailwindCSS, which means we will also need to set up a proper HTML page. If you're not familiar with TailwindCSS, don't worry, it is not required for understanding the <code>htmy</code> concepts.</p> <p>The <code>post.md</code> file can remain the same as above, but <code>app.py</code> will change quite a bit.</p> <p>First of all we need a few more imports (although some only for typing):</p> <pre><code>from htmy import Component, ComponentType, Context, PropertyValue, Renderer, etree, html, md\n</code></pre> <p>Next we need a <code>Page</code> component that defines the base HTML structure of the webpage:</p> <pre><code>class Page:\n    \"\"\"Page component that creates the basic HTML layout.\"\"\"\n\n    def __init__(self, *children: ComponentType) -&gt; None:\n        \"\"\"\n        Arguments:\n            *children: The page content.\n        \"\"\"\n        self.children = children\n\n    def htmy(self, context: Context) -&gt; Component:\n        return (\n            html.DOCTYPE.html,\n            html.html(\n                html.head(\n                    # Some metadata\n                    html.title(\"Markdown example\"),\n                    html.meta.charset(),\n                    html.meta.viewport(),\n                    # TailwindCSS import\n                    html.script(src=\"https://cdn.tailwindcss.com\"),\n                ),\n                html.body(\n                    *self.children,\n                    class_=\"h-screen w-screen p-8\",\n                ),\n            ),\n        )\n</code></pre> <p>We are getting close now, we just need to write our custom conversion rules / <code>htmy</code> component factories that will change certain tags that we encounter in the parsed markdown document:</p> <pre><code>class ConversionRules:\n    \"\"\"Conversion rules for some of the HTML elements we can encounter in parsed markdown documents.\"\"\"\n\n    @staticmethod\n    def h1(*children: ComponentType, **properties: PropertyValue) -&gt; ComponentType:\n        \"\"\"Rule for converting `h1` tags that adds some extra CSS classes to the tag.\"\"\"\n        properties[\"class\"] = f\"text-xl font-bold {properties.get('class', '')}\"\n        return html.h1(*children, **properties)\n\n    @staticmethod\n    def h2(*children: ComponentType, **properties: PropertyValue) -&gt; ComponentType:\n        \"\"\"Rule for converting `h2` tags that adds some extra CSS classes to the tag.\"\"\"\n        properties[\"class\"] = f\"text-lg font-bold {properties.get('class', '')}\"\n        return html.h2(*children, **properties)\n\n    @staticmethod\n    def ol(*children: ComponentType, **properties: PropertyValue) -&gt; ComponentType:\n        \"\"\"Rule for converting `ol` tags that adds some extra CSS classes to the tag.\"\"\"\n        properties[\"class\"] = f\"list-decimal list-inside {properties.get('class', '')}\"\n        return html.ol(*children, **properties)\n\n    @staticmethod\n    def ul(*children: ComponentType, **properties: PropertyValue) -&gt; ComponentType:\n        \"\"\"Rule for converting `ul` tags that adds some extra CSS classes to the tag.\"\"\"\n        properties[\"class\"] = f\"list-disc list-inside {properties.get('class', '')}\"\n        return html.ul(*children, **properties)\n</code></pre> <p>With the conversion rules in place, we can create our component converter by mapping tag names to conversion rules:</p> <pre><code># Create an element converter and configure it to use the conversion rules\n# that are defined above on h1, h2, ol, and ul tags.\nmd_converter = etree.ETreeConverter(\n    {\n        \"h1\": ConversionRules.h1,\n        \"h2\": ConversionRules.h2,\n        \"ol\": ConversionRules.ol,\n        \"ul\": ConversionRules.ul,\n    }\n)\n</code></pre> <p>Finally we update our <code>render_post()</code> function from the previous example to make use of all the tools we implemented above:</p> <pre><code>async def render_post() -&gt; None:\n    md_post = md.MD(  # Create an htmy.md.MD component.\n        \"post.md\",\n        converter=md_converter.convert,  # And make it use our element converter's conversion method.\n    )\n    page = Page(md_post)  # Wrap the post in a Page component.\n    rendered = await Renderer().render(page)  # Render the MD component.\n    print(rendered)  # Print the result.\n</code></pre> <p>If you run the app with <code>python app.py</code> now, you will see that the result is a complete HTML page and the <code>h1</code>, <code>h2</code>, <code>ol</code>, and <code>ul</code> tags automatically get the custom styles that we add in our <code>ConversionRules</code>.</p>"},{"location":"examples/markdown/#custom-components-in-markdown","title":"Custom components in markdown","text":"<p>In the example above, you may have noticed that while we only defined custom conversion rules for HTML tags, we could have done the same for another tag name, for example <code>\"PostInfo\"</code>. You can also have any XML in markdown files, for example <code>&lt;PostInfo author=\"John\" published_at=\"1971-10-11\" /&gt;</code>. Obviously the browser will not know what to do with this tag if we blindly keep it, but with <code>htmy</code> we can process it in any way we want.</p> <p>Building on the code from the previous section, as an example, let's add this <code>PostInfo</code> tag to <code>post.md</code> and create a custom <code>htmy</code> component for it.</p> <p>Here's the updated <code>post.md</code> file:</p> <pre><code># Essential reading\n\n&lt;PostInfo author=\"John\" published_at=\"1971-10-11\" /&gt;\n\n```python\nimport this\n```\n\nAlso available [here](https://peps.python.org/pep-0020/).\n\nInline `code` is **also** _fine_.\n\n# Lists\n\n## Ordered\n\n1. First\n2. Second\n3. Third\n\n## Unordered\n\n- First\n- Second\n- Third\n</code></pre> <p>Then we can create the <code>PostInfo</code> <code>htmy</code> component:</p> <pre><code>class PostInfo:\n    \"\"\"Component for post info rendering.\"\"\"\n\n    def __init__(self, author: str, published_at: str) -&gt; None:\n        self.author = author\n        self.published_at = published_at\n\n    def htmy(self, context: Context) -&gt; Component:\n        return html.p(\"By \", html.strong(self.author), \" at \", html.em(self.published_at), \".\")\n</code></pre> <p>Note that the arguments of <code>PostInfo.__init__()</code> match what we have in the markdown file.</p> <p>All we need now is a conversion rule for the <code>PostInfo</code> tag, so we extend the previously created converter with this rule:</p> <pre><code>md_converter = etree.ETreeConverter(\n    {\n        \"h1\": ConversionRules.h1,\n        \"h2\": ConversionRules.h2,\n        \"ol\": ConversionRules.ol,\n        \"ul\": ConversionRules.ul,\n        \"PostInfo\": PostInfo,\n    }\n)\n</code></pre> <p>If you run the app now (with <code>python app.py</code>) and open the resulting HTML in a browser, you will see that <code>&lt;PostInfo ... /&gt;</code> was nicely converted to HTML by <code>htmy</code>.</p>"},{"location":"examples/snippet-slots-fastapi/","title":"Slot rendering with <code>Snippet</code>","text":"<p>The built-in <code>Snippet</code> component can appear a bit intimidating at first with its relatively abstract, but quite powerful text processing features (<code>TextResolved</code> and <code>TextProcessor</code>), but it's actually quite simple to use. This example demonstrates how you can use it together with <code>Slots</code> to render plain <code>.html</code> files and replace slots in them with <code>htmy</code> components dynamically.</p> <p>In the example, we will build a <code>FastAPI</code> application that will serve our components using the <code>FastHX</code> library. Let's start by installing the required dependencies: <code>pip install fastapi fasthx htmy uvicorn</code>.</p> <p>We will use TailwindCSS v4 for styling, but it will be loaded from a CDN, so we don't need any JavaScript tooling. Also, you don't need to be familiar with TailwindCSS to understand the example, just ignore the styling.</p> <p>One additional note, before we start coding: the <code>MD</code> component (for markdown rendering) supports all the features of <code>Snippet</code>, so you can directly use all the patterns in this example with markdown files and the <code>MD</code> component.</p> <p>Our project structure will look like this:</p> <ul> <li><code>layout.html</code>: The HTML snippet for the <code>layout</code> <code>htmy</code> component.</li> <li><code>centered.html</code>: The HTML snippet for the <code>Centered</code> <code>htmy</code> component.</li> <li><code>app.py</code>: All our <code>htmy</code> components and the <code>FastAPI</code> application.</li> </ul> <p>Let's start by creating the <code>layout.html</code> file. Layouts often require a deeply nested component structure, so it's a good idea to use <code>Snippet</code> for then with dynamic slot rendering, because it improves performance and you can write almost the entire HTML structure in native <code>.html</code> files (without custom syntax).</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;title&gt;Snippet with Slots&lt;/title&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;script src=\"https://unpkg.com/@tailwindcss/browser@4\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body class=\"w-screen h-screen bg-gray-300 dark:bg-gray-800 dark:text-white\"&gt;\n    &lt;div class=\"w-full grid grid-rows-[max-content,1fr] p-8 gap-4\"&gt;\n      &lt;p class=\"text-center\"&gt;\n        &lt;span class=\"font-semibold text-lg\"&gt;Technologies:&lt;/span&gt;\n        &lt;a\n          href=\"https://volfpeter.github.io/htmy/\"\n          class=\"text-blue-600 visited:text-purple-600\"\n          target=\"_blank\"\n          &gt;htmy&lt;/a\n        &gt;,\n        &lt;a\n          href=\"https://volfpeter.github.io/fasthx/\"\n          class=\"text-blue-600 visited:text-purple-600\"\n          target=\"_blank\"\n          &gt;FastHX&lt;/a\n        &gt;,\n        &lt;a\n          href=\"https://fastapi.tiangolo.com/\"\n          class=\"text-blue-600 visited:text-purple-600\"\n          target=\"_blank\"\n          &gt;FastAPI&lt;/a\n        &gt;,\n        &lt;a\n          href=\"https://tailwindcss.com/\"\n          class=\"text-blue-600 visited:text-purple-600\"\n          target=\"_blank\"\n          &gt;TailwindCSSv4&lt;/a\n        &gt;.\n      &lt;/p&gt;\n      &lt;div class=\"h-full w-full\"&gt;\n        &lt;!-- slot[content] --&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>As you can see, we have the basic HTML document definition and some static content in this file, including a <code>&lt;!-- slot[content] --&gt;</code> marker (plain HTML comment), which will be resolved by <code>Snippet</code> to the correct <code>htmy</code> component during rendering.</p> <p>Next, we will create the <code>centered.html</code> file, which will be a lot simpler. Actually, it's so simple we shouldn't even use <code>Snippet</code> for it (a plain <code>htmy</code> component would be simpler and more efficient), but we will, just to showcase multiple <code>Snippet</code> usage patterns.</p> <pre><code>&lt;div class=\"flex flex-col w-full h-full items-center justify-center\"&gt;\n  &lt;!-- slot[content] --&gt;\n&lt;/div&gt;\n</code></pre> <p>This HTML file also contains a <code>&lt;!-- slot[content] --&gt;</code> marker, but the slot's key (<code>content</code>) could be anything else. The important thing, as you'll see below, is that the <code>Slots()</code> instance of the <code>Snippet()</code> contains the right component for the right slot key.</p> <p>We have all the HTML we need for our <code>Snippet</code>s, so we can finally get started with the application in <code>app.py</code>. We will do it step by step, starting with the <code>layout</code> component (factory):</p> <pre><code>from fastapi import FastAPI\nfrom fasthx.htmy import HTMY, CurrentRequest\n\nfrom htmy import ComponentType, Context, Fragment, Slots, Snippet, html\n\n\ndef layout(*children: ComponentType) -&gt; Snippet:\n    \"\"\"\n    Creates a `Snippet` that's configured to render `layout.html` with the given children\n    components replacing the `content` slot.\n    \"\"\"\n    return Snippet(\n        \"layout.html\",  # Path to the HTML snippet.\n        Slots({\"content\": children}),  # Render all children in the \"content\" slot.\n    )\n</code></pre> <p>In this case, <code>layout</code> is not even an <code>htmy</code> component, it's just a simple function that returns a <code>Snippet</code> that's configured to load the <code>layout.html</code> file we previously created, and render the given children components in place of the <code>content</code> slot.</p> <p>Now we can implement the <code>Centered</code> component. In this case we use a slightly different pattern, we subclass the component from the <code>Fragment</code> component: this way we get the <code>_children</code> property without having to write the <code>__init__(self, *children)</code> method.</p> <pre><code>class Centered(Fragment):\n    \"\"\"Component that centers its children both vertically and horizontally.\"\"\"\n\n    def htmy(self, context: Context) -&gt; Snippet:\n        return Snippet(\n            \"centered.html\",  # Path to the HTML snippet.\n            Slots({\"content\": self._children}),  # Render all children in the \"content\" slot.\n        )\n</code></pre> <p>Unlike <code>layout</code>, this component only creates the configured <code>Snippet</code> instance during rendering (in the <code>htmy()</code> method). In this simple case there's not much difference between the two patterns, but <code>Centered</code> could technically have extra state, take values from <code>context</code>, execute business logic, and use the extra data to configure the <code>Snippet</code> instance.</p> <p>We create one more component (<code>RequestHeaders</code>), just to have something that's not built with <code>Snippet</code>. This component simply shows all the headers from the current request in a grid:</p> <pre><code>class RequestHeaders:\n    \"\"\"Component that displays all the headers in the current request.\"\"\"\n\n    def htmy(self, context: Context) -&gt; html.div:\n        # Load the current request from the context.\n        request = CurrentRequest.from_context(context)\n        return html.div(\n            html.h2(\"Request headers:\", class_=\"text-lg font-semibold pb-2\"),\n            html.div(\n                *(\n                    # Convert header name and value pairs to fragments.\n                    Fragment(html.label(name + \":\"), html.label(value))\n                    for name, value in request.headers.items()\n                ),\n                class_=\"grid grid-cols-[max-content_1fr] gap-2\",\n            ),\n        )\n</code></pre> <p>The final step before creating the FastAPI application is to create a function that returns the content of the index page:</p> <pre><code>def index_page(_: None) -&gt; Snippet:\n    \"\"\"\n    Component factory that returns the index page.\n\n    Note that this function is not an `htmy` component at all, just a\n    component factory that `fasthx` decorators can resolve. It must\n    accept a single argument (the return value of the route) and return\n    the component(s) that should be rendered.\n    \"\"\"\n    return layout(Centered(RequestHeaders()))\n</code></pre> <p><code>index_page()</code>, similarly to <code>layout()</code> is also not a component, just a function that returns a component. Specifically, it shows the <code>RequestHeaders</code> component, centered in the page. We don't really need this function, we could use <code>lambda _: layout(Centered(RequestHeaders()))</code> instead in the <code>FastHX</code> <code>page()</code> decorator, but the example is more readable and easier to follow this way.</p> <p>Finally, we everything is ready, we can create the FastAPI application itself:</p> <pre><code>app = FastAPI()\n\"\"\"The FastAPI application.\"\"\"\n\nhtmy = HTMY()\n\"\"\"\nThe `HTMY` instance (from `FastHX`) that takes care of component rendering\nthrough its route decorators.\n\"\"\"\n\n\n@app.get(\"/\")\n@htmy.page(index_page)\nasync def index() -&gt; None:\n    \"\"\"The index route. It has no business logic, so it can remain empty.\"\"\"\n    ...\n</code></pre> <p>The <code>@htmy.page()</code> decorator takes care of rendering the result of the <code>index()</code> route with the component the <code>index_page()</code> function returns. The only thing that remains is to run the application with <code>python -m uvicorn app:app</code>, open http://127.0.0.1:8000 in the browser, and see the result of our work.</p>"}]}